<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Katachi Gen</title>

    <meta name="viewport" content="width=400">

    <link href="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/bootstrap.min.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" type="text/css" href="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/flat-ui.min.css"/>
    <link rel="stylesheet" type="text/css" href="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/jquery-ui.min.css"/>
    <link rel="stylesheet" type="text/css" href="css/nav.css"/>
    <link rel="stylesheet" type="text/css" href="css/main.css"/>

    <script>
        window.nftRenderComplete = false;

        const origamiPatterns = [
            {url:"https://arweave.net/DEwA5RuJrMaZo4tHYmtKXV0gPXHJBC0p16HbhFqA15k", maxFolding:95, name:"airplane.svg"},
            {url:"https://arweave.net/aeUK83c7uqmpWCUwwwv0Ao-_Ttxs_9XMcrznkjwXOqs", maxFolding:100, name:"birdBase.svg"},
            {url:"https://arweave.net/l-mOj-cl7LGG7IjNWnZv1LIFLM_no_6gisnK53XD9Os", maxFolding:70, name:"hypar.svg"},
            {url:"https://arweave.net/G3TfyqgWOlSdxjluMhnhswxZANT4waZdBh69HwllFCQ", maxFolding:80, name:"pinwheelBase.svg"},
            {url:"https://arweave.net/4Y1SaF832toY5ac9fXqkQlaN_xmGqGWaOfcj0txzyg0", maxFolding:97, name:"traditionalCrane.svg"},
            {url:"https://arweave.net/59F93UIm1IJCWflSrWq_IsENxzvllCxz5QtwBky4xGM", maxFolding:70, name:"FTpoly7.svg"},
        ];
        
        
        // This will be replaced with actual data
        const nftData = `{dataJson}`;
//         const nftData = JSON.parse(`
// {
//     "walletAddress":"0x1234567890abcdef",
//     "seed2":"${Math.random()}",
//     "images":[
//         {"url":"https://exonemo.com/test/katachi-gen/images/aventurine.avif"},
//         {"url":"https://exonemo.com/test/katachi-gen/images/infinitegarden.webp"},
//         {"url":"https://exonemo.com/test/katachi-gen/images/gmmoney-die.webp"},
//         {"url":"https://exonemo.com/test/katachi-gen/images/ocote-tekno.gif"},
//         {"url":"https://exonemo.com/test/katachi-gen/images/karborn.webp"}
//     ]
// }
//         `);
    const editMode = false;
    window.editMode = editMode; 

    </script>

    <style>
        /* Styles for non-edit mode */
        .edit-mode-disabled #globalNav {
            display: none !important;
        }
        
        .edit-mode-disabled body {
            padding-top: 0 !important; /* Remove top padding when nav is hidden */
        }
        
        .edit-mode-disabled .main-content {
            margin-top: 0 !important; /* Adjust main content position */
        }
    </style>

    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
           gl_Position = vec4(a_position, 0, 1);
        }
    </script>

    <script id="packToBytesShader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_floatTextureDim;
        uniform sampler2D u_floatTexture;
        uniform float u_vectorLength;
        float shift_right (float v, float amt) {
            v = floor(v) + 0.5;
            return floor(v / exp2(amt));
        }
        float shift_left (float v, float amt) {
            return floor(v * exp2(amt) + 0.5);
        }
        float mask_last (float v, float bits) {
            return mod(v, shift_left(1.0, bits));
        }
        float extract_bits (float num, float from, float to) {
            from = floor(from + 0.5); to = floor(to + 0.5);
            return mask_last(shift_right(num, from), to - from);
        }
        vec4 encode_float (float val) {
            if (val == 0.0) return vec4(0, 0, 0, 0);
            float sign = val > 0.0 ? 0.0 : 1.0;
            val = abs(val);
            float exponent = floor(log2(val));
            float biased_exponent = exponent + 127.0;
            float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;
            float t = biased_exponent / 2.0;
            float last_bit_of_biased_exponent = fract(t) * 2.0;
            float remaining_bits_of_biased_exponent = floor(t);
            float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;
            float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;
            float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;
            float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;
            return vec4(byte4, byte3, byte2, byte1);
        }
        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            float textureXcoord = floor((fragCoord.x - 0.5)/u_vectorLength+0.0001) + 0.5;
            vec4 data = texture2D(u_floatTexture, vec2(textureXcoord, fragCoord.y)/u_floatTextureDim);
            int textureIndex = int(floor(mod(fragCoord.x-0.5+0.0001, u_vectorLength)));
            if (textureIndex == 0) gl_FragColor = encode_float(data[0]);
            else if (textureIndex == 1) gl_FragColor = encode_float(data[1]);
            else if (textureIndex == 2) gl_FragColor = encode_float(data[2]);
            else if (textureIndex == 3) gl_FragColor = encode_float(data[3]);
        }
    </script>

    <script id="zeroTexture" type="x-shader/x-fragment">
        precision mediump float;
        void main(){
            gl_FragColor = vec4(0.0);
        }
    </script>
    <script id="zeroThetaTexture" type="x-shader/x-fragment">
        precision mediump float;
        uniform sampler2D u_theta;
        uniform vec2 u_textureDimCreases;
        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDimCreases;
            vec4 theta = texture2D(u_theta, scaledFragCoord);
            gl_FragColor = vec4(0.0, 0.0, theta[2], theta[3]);
        }
    </script>
    <script id="centerTexture" type="x-shader/x-fragment">
        precision mediump float;
        uniform sampler2D u_lastPosition;
        uniform vec2 u_textureDim;
        uniform vec3 u_center;
        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDim;
            vec3 position = texture2D(u_lastPosition, scaledFragCoord).xyz;
            gl_FragColor = vec4(position-u_center, 0.0);
        }
    </script>
    <script id="copyTexture" type="x-shader/x-fragment">
        precision mediump float;
        uniform sampler2D u_orig;
        uniform vec2 u_textureDim;
        void main(){
            gl_FragColor = texture2D(u_orig, gl_FragCoord.xy/u_textureDim);
        }
    </script>

    <script id="positionCalcShader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_textureDim;
        uniform float u_dt;
        uniform sampler2D u_lastPosition;
        uniform sampler2D u_velocity;
        uniform sampler2D u_mass;

        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDim;

            vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;

            float isFixed = texture2D(u_mass, scaledFragCoord).y;
            if (isFixed == 1.0){
                gl_FragColor = vec4(lastPosition, 0.0);
                return;
            }

            vec4 velocityData = texture2D(u_velocity, scaledFragCoord);
            vec3 position = velocityData.xyz*u_dt + lastPosition;
            gl_FragColor = vec4(position, velocityData.a);//velocity.a has error info
        }
    </script>

    <script id="velocityCalcVerletShader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_textureDim;
        uniform float u_dt;
        uniform sampler2D u_position;
        uniform sampler2D u_lastPosition;
        uniform sampler2D u_mass;

        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDim;

            float isFixed = texture2D(u_mass, scaledFragCoord).y;
            if (isFixed == 1.0){
                gl_FragColor = vec4(0.0);
                return;
            }

            vec3 position = texture2D(u_position, scaledFragCoord).xyz;
            vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;
            gl_FragColor = vec4((position-lastPosition)/u_dt,0.0);
        }
    </script>

    <script id="velocityCalcShader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_textureDim;
        uniform vec2 u_textureDimEdges;
        uniform vec2 u_textureDimFaces;
        uniform vec2 u_textureDimCreases;
        uniform vec2 u_textureDimNodeCreases;
        uniform vec2 u_textureDimNodeFaces;
        uniform float u_creasePercent;
        uniform float u_dt;
        uniform float u_axialStiffness;
        uniform float u_faceStiffness;
        uniform sampler2D u_lastPosition;
        uniform sampler2D u_lastVelocity;
        uniform sampler2D u_originalPosition;
        uniform sampler2D u_externalForces;
        uniform sampler2D u_mass;
        uniform sampler2D u_meta;//[beamsIndex, numBeam, nodeCreaseMetaIndex, numCreases]
        uniform sampler2D u_beamMeta;//[k, d, length, otherNodeIndex]
        uniform sampler2D u_creaseMeta;//[k, d, targetTheta]
        uniform sampler2D u_nodeCreaseMeta;//[creaseIndex, nodeIndex, -, -]
        uniform sampler2D u_normals;
        uniform sampler2D u_theta;//[theta, z, normal1Index, normal2Index]
        uniform sampler2D u_creaseGeo;//[h1, h2, coef1, coef2]
        uniform sampler2D u_meta2;//[nodesFaceIndex, numFaces]
        uniform sampler2D u_nodeFaceMeta;//[faceIndex, a, b, c]
        uniform sampler2D u_nominalTriangles;//[angleA, angleB, angleC]
        uniform bool u_calcFaceStrain;

        vec4 getFromArray(float index1D, vec2 dimensions, sampler2D tex){
            vec2 index = vec2(mod(index1D, dimensions.x)+0.5, floor(index1D/dimensions.x)+0.5);
            vec2 scaledIndex = index/dimensions;
            return texture2D(tex, scaledIndex);
        }

        vec3 getPosition(float index1D){
            vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);
            vec2 scaledIndex = index/u_textureDim;
            return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;
        }

        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDim;

            vec2 mass = texture2D(u_mass, scaledFragCoord).xy;
            if (mass[1] == 1.0){//fixed
                gl_FragColor = vec4(0.0);
                return;
            }
            vec3 force = texture2D(u_externalForces, scaledFragCoord).xyz;
            vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;
            vec3 lastVelocity = texture2D(u_lastVelocity, scaledFragCoord).xyz;
            vec3 originalPosition = texture2D(u_originalPosition, scaledFragCoord).xyz;

            vec4 neighborIndices = texture2D(u_meta, scaledFragCoord);
            vec4 meta = texture2D(u_meta, scaledFragCoord);
            vec2 meta2 = texture2D(u_meta2, scaledFragCoord).xy;

            float nodeError = 0.0;

            for (int j=0;j<100;j++){//for all beams (up to 100, had to put a const int in here)
                if (j >= int(meta[1])) break;

                vec4 beamMeta = getFromArray(meta[0]+float(j), u_textureDimEdges, u_beamMeta);

                float neighborIndex1D = beamMeta[3];
                vec2 neighborIndex = vec2(mod(neighborIndex1D, u_textureDim.x)+0.5, floor(neighborIndex1D/u_textureDim.x)+0.5);
                vec2 scaledNeighborIndex = neighborIndex/u_textureDim;
                vec3 neighborLastPosition = texture2D(u_lastPosition, scaledNeighborIndex).xyz;
                vec3 neighborLastVelocity = texture2D(u_lastVelocity, scaledNeighborIndex).xyz;
                vec3 neighborOriginalPosition = texture2D(u_originalPosition, scaledNeighborIndex).xyz;

                vec3 nominalDist = neighborOriginalPosition-originalPosition;
                vec3 deltaP = neighborLastPosition-lastPosition+nominalDist;
                float deltaPLength = length(deltaP);
                deltaP -= deltaP*(beamMeta[2]/deltaPLength);
                if (!u_calcFaceStrain) nodeError += abs(deltaPLength/length(nominalDist) - 1.0);
                vec3 deltaV = neighborLastVelocity-lastVelocity;

                vec3 _force = deltaP*beamMeta[0] + deltaV*beamMeta[1];
                force += _force;
            }
            if (!u_calcFaceStrain) nodeError /= meta[1];

            for (int j=0;j<100;j++){//for all creases (up to 100, had to put a const int in here)
                if (j >= int(meta[3])) break;

                vec4 nodeCreaseMeta = getFromArray(meta[2]+float(j), u_textureDimNodeCreases, u_nodeCreaseMeta);

                float creaseIndex1D = nodeCreaseMeta[0];
                vec2 creaseIndex = vec2(mod(creaseIndex1D, u_textureDimCreases.x)+0.5, floor(creaseIndex1D/u_textureDimCreases.x)+0.5);
                vec2 scaledCreaseIndex = creaseIndex/u_textureDimCreases;

                vec4 thetas = texture2D(u_theta, scaledCreaseIndex);
                vec3 creaseMeta = texture2D(u_creaseMeta, scaledCreaseIndex).xyz;//[k, d, targetTheta]
                vec4 creaseGeo = texture2D(u_creaseGeo, scaledCreaseIndex);//[h1, h2, coef1, coef2]
                if (creaseGeo[0]< 0.0) continue;//crease disabled bc it has collapsed too much

                float targetTheta = creaseMeta[2] * u_creasePercent;
                float angForce = creaseMeta[0]*(targetTheta-thetas[0]);// + creaseMeta[1]*thetas[1];

                float nodeNum = nodeCreaseMeta[1];//1, 2, 3, 4

                if (nodeNum > 2.0){//crease reaction, node is on a crease

                    //node #1
                    vec3 normal1 = getFromArray(thetas[2], u_textureDimFaces, u_normals).xyz;

                    //node #2
                    vec3 normal2 = getFromArray(thetas[3], u_textureDimFaces, u_normals).xyz;

                    float coef1 = creaseGeo[2];
                    float coef2 = creaseGeo[3];

                    if (nodeNum == 3.0){
                        coef1 = 1.0-coef1;
                        coef2 = 1.0-coef2;
                    }

                    vec3 _force = -angForce*(coef1/creaseGeo[0]*normal1 + coef2/creaseGeo[1]*normal2);
                    force += _force;

                } else {

                    float normalIndex1D = thetas[2];//node #1
                    float momentArm = creaseGeo[0];//node #1
                    if (nodeNum == 2.0) {
                        normalIndex1D = thetas[3];//node #2
                        momentArm = creaseGeo[1];//node #2
                    }

                    vec3 normal = getFromArray(normalIndex1D, u_textureDimFaces, u_normals).xyz;

                    vec3 _force = angForce/momentArm*normal;
                    force += _force;
                }
            }

            for (int j=0;j<100;j++){//for all faces (up to 100, had to put a const int in here)
                if (j >= int(meta2[1])) break;

                vec4 faceMeta = getFromArray(meta2[0]+float(j), u_textureDimNodeFaces, u_nodeFaceMeta);//[face index, a, b, c]
                vec3 nominalAngles = getFromArray(faceMeta[0], u_textureDimFaces, u_nominalTriangles).xyz;//[angA, angB, angC]

                int faceIndex = 0;
                if (faceMeta[2] < 0.0) faceIndex = 1;
                if (faceMeta[3] < 0.0) faceIndex = 2;

                //get node positions
                vec3 a = faceIndex == 0 ? lastPosition+originalPosition : getPosition(faceMeta[1]);
                vec3 b = faceIndex == 1 ? lastPosition+originalPosition : getPosition(faceMeta[2]);
                vec3 c = faceIndex == 2 ? lastPosition+originalPosition : getPosition(faceMeta[3]);

                //calc angles
                vec3 ab = b-a;
                vec3 ac = c-a;
                vec3 bc = c-b;

                float lengthAB = length(ab);
                float lengthAC = length(ac);
                float lengthBC = length(bc);

                float tol = 0.0000001;
                if (abs(lengthAB) < tol || abs(lengthBC) < tol || abs(lengthAC) < tol) continue;

                ab /= lengthAB;
                ac /= lengthAC;
                bc /= lengthBC;

                vec3 angles = vec3(acos(dot(ab, ac)),
                    acos(-1.0*dot(ab, bc)),
                    acos(dot(ac, bc)));
                vec3 anglesDiff = nominalAngles-angles;

                vec3 normal = getFromArray(faceMeta[0], u_textureDimFaces, u_normals).xyz;

                //calc forces
                anglesDiff *= u_faceStiffness;
                if (faceIndex == 0){//a
                    vec3 normalCrossAC = cross(normal, ac)/lengthAC;
                    vec3 normalCrossAB = cross(normal, ab)/lengthAB;
                    force -= anglesDiff[0]*(normalCrossAC - normalCrossAB);
                    if (u_calcFaceStrain) nodeError += abs((nominalAngles[0]-angles[0])/nominalAngles[0]);
                    force -= anglesDiff[1]*normalCrossAB;
                    force += anglesDiff[2]*normalCrossAC;
                } else if (faceIndex == 1){
                    vec3 normalCrossAB = cross(normal, ab)/lengthAB;
                    vec3 normalCrossBC = cross(normal, bc)/lengthBC;
                    force -= anglesDiff[0]*normalCrossAB;
                    force += anglesDiff[1]*(normalCrossAB + normalCrossBC);
                    if (u_calcFaceStrain) nodeError += abs((nominalAngles[1]-angles[1])/nominalAngles[1]);
                    force -= anglesDiff[2]*normalCrossBC;
                } else if (faceIndex == 2){
                    vec3 normalCrossAC = cross(normal, ac)/lengthAC;
                    vec3 normalCrossBC = cross(normal, bc)/lengthBC;
                    force += anglesDiff[0]*normalCrossAC;
                    force -= anglesDiff[1]*normalCrossBC;
                    force += anglesDiff[2]*(normalCrossBC - normalCrossAC);
                    if (u_calcFaceStrain) nodeError += abs((nominalAngles[2]-angles[2])/nominalAngles[2]);
                }

            }
            if (u_calcFaceStrain) nodeError /= meta2[1];

            vec3 velocity = force*u_dt/mass[0] + lastVelocity;
            gl_FragColor = vec4(velocity,nodeError);
        }
    </script>

    <script id="positionCalcVerletShader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_textureDim;
        uniform vec2 u_textureDimEdges;
        uniform vec2 u_textureDimFaces;
        uniform vec2 u_textureDimCreases;
        uniform vec2 u_textureDimNodeCreases;
        uniform vec2 u_textureDimNodeFaces;
        uniform float u_creasePercent;
        uniform float u_dt;
        uniform float u_axialStiffness;
        uniform float u_faceStiffness;
        uniform sampler2D u_lastPosition;
        uniform sampler2D u_lastLastPosition;
        uniform sampler2D u_lastVelocity;
        uniform sampler2D u_originalPosition;
        uniform sampler2D u_externalForces;
        uniform sampler2D u_mass;
        uniform sampler2D u_meta;//[beamsIndex, numBeam, nodeCreaseMetaIndex, numCreases]
        uniform sampler2D u_beamMeta;//[k, d, length, otherNodeIndex]
        uniform sampler2D u_creaseMeta;//[k, d, targetTheta]
        uniform sampler2D u_nodeCreaseMeta;//[creaseIndex, nodeIndex, -, -]
        uniform sampler2D u_normals;
        uniform sampler2D u_theta;//[theta, z, normal1Index, normal2Index]
        uniform sampler2D u_creaseGeo;//[h1, h2, coef1, coef2]
        uniform sampler2D u_meta2;//[nodesFaceIndex, numFaces]
        uniform sampler2D u_nodeFaceMeta;//[faceIndex, a, b, c]
        uniform sampler2D u_nominalTriangles;//[angleA, angleB, angleC]

        vec4 getFromArray(float index1D, vec2 dimensions, sampler2D tex){
            vec2 index = vec2(mod(index1D, dimensions.x)+0.5, floor(index1D/dimensions.x)+0.5);
            vec2 scaledIndex = index/dimensions;
            return texture2D(tex, scaledIndex);
        }

        vec3 getPosition(float index1D){
            vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);
            vec2 scaledIndex = index/u_textureDim;
            return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;
        }

        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDim;

            vec3 lastPosition = texture2D(u_lastPosition, scaledFragCoord).xyz;

            vec2 mass = texture2D(u_mass, scaledFragCoord).xy;
            if (mass[1] == 1.0){//fixed
                gl_FragColor = vec4(lastPosition, 0.0);
                return;
            }
            vec3 force = texture2D(u_externalForces, scaledFragCoord).xyz;
            vec3 lastLastPosition = texture2D(u_lastLastPosition, scaledFragCoord).xyz;
            vec3 lastVelocity = texture2D(u_lastVelocity, scaledFragCoord).xyz;
            vec3 originalPosition = texture2D(u_originalPosition, scaledFragCoord).xyz;

            vec4 neighborIndices = texture2D(u_meta, scaledFragCoord);
            vec4 meta = texture2D(u_meta, scaledFragCoord);
            vec2 meta2 = texture2D(u_meta2, scaledFragCoord).xy;

            float nodeError = 0.0;

            for (int j=0;j<100;j++){//for all beams (up to 100, had to put a const int in here)
                if (j >= int(meta[1])) break;

                vec4 beamMeta = getFromArray(meta[0]+float(j), u_textureDimEdges, u_beamMeta);

                float neighborIndex1D = beamMeta[3];
                vec2 neighborIndex = vec2(mod(neighborIndex1D, u_textureDim.x)+0.5, floor(neighborIndex1D/u_textureDim.x)+0.5);
                vec2 scaledNeighborIndex = neighborIndex/u_textureDim;
                vec3 neighborLastPosition = texture2D(u_lastPosition, scaledNeighborIndex).xyz;
                vec3 neighborLastVelocity = texture2D(u_lastVelocity, scaledNeighborIndex).xyz;
                vec3 neighborOriginalPosition = texture2D(u_originalPosition, scaledNeighborIndex).xyz;

                vec3 deltaP = neighborLastPosition+neighborOriginalPosition-lastPosition-originalPosition;
                float deltaPLength = length(deltaP);
                float nominalLength = beamMeta[2];
                deltaP *= (1.0-nominalLength/deltaPLength);
                nodeError += abs(deltaPLength/nominalLength - 1.0);
                vec3 deltaV = neighborLastVelocity-lastVelocity;

                vec3 _force = deltaP*beamMeta[0] + deltaV*beamMeta[1];
                force += _force;
            }
            nodeError /= meta[1];

            for (int j=0;j<100;j++){//for all creases (up to 100, had to put a const int in here)
                if (j >= int(meta[3])) break;

                vec4 nodeCreaseMeta = getFromArray(meta[2]+float(j), u_textureDimNodeCreases, u_nodeCreaseMeta);

                float creaseIndex1D = nodeCreaseMeta[0];
                vec2 creaseIndex = vec2(mod(creaseIndex1D, u_textureDimCreases.x)+0.5, floor(creaseIndex1D/u_textureDimCreases.x)+0.5);
                vec2 scaledCreaseIndex = creaseIndex/u_textureDimCreases;

                vec4 thetas = texture2D(u_theta, scaledCreaseIndex);
                vec3 creaseMeta = texture2D(u_creaseMeta, scaledCreaseIndex).xyz;//[k, d, targetTheta]
                vec4 creaseGeo = texture2D(u_creaseGeo, scaledCreaseIndex);//[h1, h2, coef1, coef2]
                if (creaseGeo[0]< 0.0) continue;//crease disabled bc it has collapsed too much

                float targetTheta = creaseMeta[2] * u_creasePercent;
                float angForce = creaseMeta[0]*(targetTheta-thetas[0]);// + creaseMeta[1]*thetas[1];

                float nodeNum = nodeCreaseMeta[1];//1, 2, 3, 4

                if (nodeNum > 2.0){//crease reaction, node is on a crease

                    //node #1
                    vec3 normal1 = getFromArray(thetas[2], u_textureDimFaces, u_normals).xyz;

                    //node #2
                    vec3 normal2 = getFromArray(thetas[3], u_textureDimFaces, u_normals).xyz;

                    float coef1 = creaseGeo[2];
                    float coef2 = creaseGeo[3];

                    if (nodeNum == 3.0){
                        coef1 = 1.0-coef1;
                        coef2 = 1.0-coef2;
                    }

                    vec3 _force = -angForce*(coef1/creaseGeo[0]*normal1 + coef2/creaseGeo[1]*normal2);
                    force += _force;

                } else {

                    float normalIndex1D = thetas[2];//node #1
                    float momentArm = creaseGeo[0];//node #1
                    if (nodeNum == 2.0) {
                        normalIndex1D = thetas[3];//node #2
                        momentArm = creaseGeo[1];//node #2
                    }

                    vec3 normal = getFromArray(normalIndex1D, u_textureDimFaces, u_normals).xyz;

                    vec3 _force = angForce/momentArm*normal;
                    force += _force;
                }
            }

            for (int j=0;j<100;j++){//for all faces (up to 100, had to put a const int in here)
                if (j >= int(meta2[1])) break;

                vec4 faceMeta = getFromArray(meta2[0]+float(j), u_textureDimNodeFaces, u_nodeFaceMeta);//[face index, a, b, c]
                vec3 nominalAngles = getFromArray(faceMeta[0], u_textureDimFaces, u_nominalTriangles).xyz;//[angA, angB, angC]

                int faceIndex = 0;
                if (faceMeta[2] < 0.0) faceIndex = 1;
                if (faceMeta[3] < 0.0) faceIndex = 2;

                //get node positions
                vec3 a = faceIndex == 0 ? lastPosition+originalPosition : getPosition(faceMeta[1]);
                vec3 b = faceIndex == 1 ? lastPosition+originalPosition : getPosition(faceMeta[2]);
                vec3 c = faceIndex == 2 ? lastPosition+originalPosition : getPosition(faceMeta[3]);

                //calc angles
                vec3 ab = b-a;
                vec3 ac = c-a;
                vec3 bc = c-b;

                float lengthAB = length(ab);
                float lengthAC = length(ac);
                float lengthBC = length(bc);

                float tol = 0.0000001;
                if (abs(lengthAB) < tol || abs(lengthBC) < tol || abs(lengthAC) < tol) continue;

                ab /= lengthAB;
                ac /= lengthAC;
                bc /= lengthBC;

                vec3 angles = vec3(acos(dot(ab, ac)),
                    acos(-1.0*dot(ab, bc)),
                    acos(dot(ac, bc)));
                vec3 anglesDiff = nominalAngles-angles;

                vec3 normal = getFromArray(faceMeta[0], u_textureDimFaces, u_normals).xyz;

                //calc forces
                anglesDiff *= u_faceStiffness;
                if (faceIndex == 0){//a
                    vec3 normalCrossAC = cross(normal, ac)/lengthAC;
                    vec3 normalCrossAB = cross(normal, ab)/lengthAB;
                    force -= anglesDiff[0]*(normalCrossAC - normalCrossAB);
                    force -= anglesDiff[1]*normalCrossAB;
                    force += anglesDiff[2]*normalCrossAC;
                } else if (faceIndex == 1){
                    vec3 normalCrossAB = cross(normal, ab)/lengthAB;
                    vec3 normalCrossBC = cross(normal, bc)/lengthBC;
                    force -= anglesDiff[0]*normalCrossAB;
                    force += anglesDiff[1]*(normalCrossAB + normalCrossBC);
                    force -= anglesDiff[2]*normalCrossBC;
                } else if (faceIndex == 2){
                    vec3 normalCrossAC = cross(normal, ac)/lengthAC;
                    vec3 normalCrossBC = cross(normal, bc)/lengthBC;
                    force += anglesDiff[0]*normalCrossAC;
                    force -= anglesDiff[1]*normalCrossBC;
                    force += anglesDiff[2]*(normalCrossBC - normalCrossAC);
                }

            }

            vec3 nextPosition = force*u_dt*u_dt/mass[0] + 2.0*lastPosition - lastLastPosition;
            gl_FragColor = vec4(nextPosition,nodeError);//position.a has error info
        }
    </script>

    <script id="thetaCalcShader" type="x-shader/x-fragment">
        #define TWO_PI 6.283185307179586476925286766559
        precision mediump float;
        uniform vec2 u_textureDim;
        uniform vec2 u_textureDimFaces;
        uniform vec2 u_textureDimCreases;
        uniform sampler2D u_normals;
        uniform sampler2D u_lastTheta;
        uniform sampler2D u_creaseVectors;
        uniform sampler2D u_lastPosition;
        uniform sampler2D u_originalPosition;
        uniform float u_dt;

        vec4 getFromArray(float index1D, vec2 dimensions, sampler2D tex){
            vec2 index = vec2(mod(index1D, dimensions.x)+0.5, floor(index1D/dimensions.x)+0.5);
            vec2 scaledIndex = index/dimensions;
            return texture2D(tex, scaledIndex);
        }

        void main(){

            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDimCreases;

            vec4 lastTheta = texture2D(u_lastTheta, scaledFragCoord);

            if (lastTheta[2]<0.0){
                gl_FragColor = vec4(lastTheta[0], 0.0, -1.0, -1.0);
                return;
            }

            vec3 normal1 = getFromArray(lastTheta[2], u_textureDimFaces, u_normals).xyz;
            vec3 normal2 = getFromArray(lastTheta[3], u_textureDimFaces, u_normals).xyz;

            float dotNormals = dot(normal1, normal2);//normals are already normalized, no need to divide by length
            if (dotNormals < -1.0) dotNormals = -1.0;
            else if (dotNormals > 1.0) dotNormals = 1.0;

            vec2 creaseVectorIndices = texture2D(u_creaseVectors, scaledFragCoord).xy;
            vec2 creaseNodeIndex = vec2(mod(creaseVectorIndices[0], u_textureDim.x)+0.5, floor(creaseVectorIndices[0]/u_textureDim.x)+0.5);
            vec2 scaledNodeIndex = creaseNodeIndex/u_textureDim;
            vec3 node0 = texture2D(u_lastPosition, scaledNodeIndex).xyz + texture2D(u_originalPosition, scaledNodeIndex).xyz;
            creaseNodeIndex = vec2(mod(creaseVectorIndices[1], u_textureDim.x)+0.5, floor(creaseVectorIndices[1]/u_textureDim.x)+0.5);
            scaledNodeIndex = creaseNodeIndex/u_textureDim;
            vec3 node1 = texture2D(u_lastPosition, scaledNodeIndex).xyz + texture2D(u_originalPosition, scaledNodeIndex).xyz;

            //https://math.stackexchange.com/questions/47059/how-do-i-calculate-a-dihedral-angle-given-cartesian-coordinates
            vec3 creaseVector = normalize(node1-node0);
            float x = dotNormals;
            float y = dot(cross(normal1, creaseVector), normal2);

            float theta = atan(y, x);

            float diff = theta-lastTheta[0];
            float origDiff = diff;
            if (diff < -5.0) {
                diff += TWO_PI;
            } else if (diff > 5.0) {
                diff -= TWO_PI;
            }
            theta = lastTheta[0] + diff;
            gl_FragColor = vec4(theta, diff, lastTheta[2], lastTheta[3]);//[theta, w, normal1Index, normal2Index]
        }
    </script>

    <script id="normalCalc" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_textureDim;
        uniform vec2 u_textureDimFaces;
        uniform sampler2D u_faceVertexIndices;
        uniform sampler2D u_lastPosition;
        uniform sampler2D u_originalPosition;

        vec3 getPosition(float index1D){
            vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);
            vec2 scaledIndex = index/u_textureDim;
            return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;
        }

        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDimFaces;

            vec3 indices = texture2D(u_faceVertexIndices, scaledFragCoord).xyz;

            vec3 a = getPosition(indices[0]);
            vec3 b = getPosition(indices[1]);
            vec3 c = getPosition(indices[2]);

            vec3 normal = normalize(cross(b-a, c-a));

            gl_FragColor = vec4(normal, 0.0);
        }
    </script>

    <script id="updateCreaseGeo" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_textureDim;
        uniform vec2 u_textureDimCreases;
        uniform sampler2D u_lastPosition;
        uniform sampler2D u_originalPosition;
        uniform sampler2D u_creaseMeta2;

        vec3 getPosition(float index1D){
            vec2 index = vec2(mod(index1D, u_textureDim.x)+0.5, floor(index1D/u_textureDim.x)+0.5);
            vec2 scaledIndex = index/u_textureDim;
            return texture2D(u_lastPosition, scaledIndex).xyz + texture2D(u_originalPosition, scaledIndex).xyz;
        }

        void main(){
            vec2 fragCoord = gl_FragCoord.xy;
            vec2 scaledFragCoord = fragCoord/u_textureDimCreases;

            vec4 creaseMeta = texture2D(u_creaseMeta2, scaledFragCoord);

            vec3 node1 = getPosition(creaseMeta[0]);
            vec3 node2 = getPosition(creaseMeta[1]);
            vec3 node3 = getPosition(creaseMeta[2]);
            vec3 node4 = getPosition(creaseMeta[3]);

            float tol = 0.000001;

            vec3 creaseVector = node4-node3;
            float creaseLength = length(creaseVector);

            if (abs(creaseLength)<tol) {
                gl_FragColor = vec4(-1);//disable crease
                return;
            }
            creaseVector /= creaseLength;

            vec3 vector1 = node1-node3;
            vec3 vector2 = node2-node3;

            float proj1Length = dot(creaseVector, vector1);
            float proj2Length = dot(creaseVector, vector2);

            float dist1 = sqrt(abs(vector1.x*vector1.x+vector1.y*vector1.y+vector1.z*vector1.z-proj1Length*proj1Length));
            float dist2 = sqrt(abs(vector2.x*vector2.x+vector2.y*vector2.y+vector2.z*vector2.z-proj2Length*proj2Length));

            if (dist1<tol || dist2<tol){
                gl_FragColor = vec4(-1);//disable crease
                return;
            }

            gl_FragColor = vec4(dist1, dist2, proj1Length/creaseLength, proj2Length/creaseLength);
        }
    </script>

    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/jquery-3.2.1.min.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/jquery-ui.min.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/flat-ui.min.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/three.min.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/binary_stl_writer.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/TrackballControls.js"></script>
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/Projector.js"></script>-->
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/SVGRenderer.js"></script>-->
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/underscore-min.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/FileSaver.min.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/SVGLoader.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/OBJExporter.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/path-data-polyfill.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/earcut.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/fold.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/CCapture.all.min.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/numeric-1.2.6.js"></script>

    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/EffectComposer.js"></script>-->
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/MaskPass.js"></script>-->
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/ShaderPass.js"></script>-->
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/CopyShader.js"></script>-->
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/SSAOShader.js"></script>-->
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/Detector.js"></script>-->
    <!--<script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/RenderPass.js"></script>-->

    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/WebVR.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/VRController.js"></script>
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/datguivr.js"></script><!--made a lot of changes, don't replace with minified-->

    <script type="text/javascript" src="js/dynamic/GLBoilerplate.js"></script>
    <script type="text/javascript" src="js/dynamic/GPUMath.js"></script>
    <script type="text/javascript" src="js/controls.js"></script>
    <script type="text/javascript" src="js/threeView.js"></script>
    <script type="text/javascript" src="js/globals.js"></script>
    <script type="text/javascript" src="js/node.js"></script>
    <script type="text/javascript" src="js/beam.js"></script>
    <script type="text/javascript" src="js/crease.js"></script>
    <script type="text/javascript" src="js/model.js"></script>
    <script type="text/javascript" src="js/3dUI.js"></script>
    <script type="text/javascript" src="js/staticSolver.js"></script>
    <script type="text/javascript" src="js/dynamic/dynamicSolver.js"></script>
    <script type="text/javascript" src="js/rigidSolver.js"></script>
    <script type="text/javascript" src="js/pattern.js"></script>
    <script type="text/javascript" src="js/saveSTL.js"></script>
    <script type="text/javascript" src="js/saveFOLD.js"></script>
    <script type="text/javascript" src="js/cellColorizer.js"></script>
    <script type="text/javascript" src="js/importer.js"></script>
    <script type="text/javascript" src="js/VRInterface.js"></script>
    <script type="text/javascript" src="js/videoAnimator.js"></script>

    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/cdt2d.js"></script><!-- constrained delaunay triangulation -->
    <script type="text/javascript" src="https://arweave.net/PalygydxpOrQIy25uGoQ-uBQ_8gJ6ZfAmzB40v9o8Ys/svgpath.js"></script>
    <script type="text/javascript" src="js/curvedFolding.js"></script>

    <script type="text/javascript" src="js/main.js"></script>
</head>
<body>

<nav id="globalNav" class="navbar navbar-inverse navbar-embossed" role="navigation">
    <div class="navbar-header">
        <a id="logo" class="navbar-brand" target="_blank" href="https://amandaghassaei.com/">
            <img id="inactiveLogo" src="assets/logo.png"/>
            <img id="activeLogo" src="assets/logo-active.png"/>
        </a>
    </div>
    <div class="collapse navbar-collapse" id="navbar-collapse-01">
        <ul class="nav navbar-nav navbar-left">
            <li class="dropdown navDropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">File <b class="caret"></b></a>
                <span class="dropdown-arrow"></span>
                <ul class="dropdown-menu">
                    <li><a class="loadFile" href="#">Import... (SVG / FOLD)</a></li>
                    <!--<li><a id="importSettings" href="#">SVG Import Settings...</a></li>-->
                    <li><a id="tips" href="#">Design Tips</a></li>
                    <li class="divider"></li>
                    <li><a id="createGif" href="#">Record animated GIF...</a></li>
                    <li><a id="createVideo" href="#">Record video...</a></li>
                    <li><a id="createPNG" href="#">Save PNG screenshot...</a></li>
                    <li class="divider"></li>
                    <li><a id="exportFOLD" href="#">Save Simulation as FOLD...</a></li>
                    <li><a id="exportSTL" href="#">Save Simulation as STL...</a></li>
                    <li><a id="exportOBJ" href="#">Save Simulation as OBJ...</a></li>
                    <li class="divider"></li>
                    <li><a id="saveSVG" href="#">Save Pattern as SVG...</a></li>
                    <li><a id="generateCellMap" href="#">Generate Colored Cell Map...</a></li>
                    <li><a id="generateTextureMappedCells" href="#">Generate Texture-Mapped Cells...</a></li>
                    <!--<li><a id="saveSVGScreenshot" href="#">Save SVG screenshot</a></li>-->
                </ul>
            </li>
            <li class="dropdown navDropdown">
                <a href="#" id="exampleMenuButton" class="dropdown-toggle" data-toggle="dropdown">Examples <b class="caret"></b></a>
                <span class="dropdown-arrow"></span>
                <ul class="dropdown-menu" style="min-width: 200px;">
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Origami<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo" data-url="Origami/flappingBird.svg">Flapping Bird</a></li>
                            <li><a href="#" class="demo author" data-author="randlett" data-url="Origami/randlettflappingbird.svg">Randlett Flapping Bird</a></li>
                            <li><a href="#" class="demo" data-url="Origami/traditionalCrane.svg">Crane (3D)</a></li>
                            <li><a href="#" class="demo" data-url="Origami/flat_crane.svg">Crane (flat)</a></li>
                            <li><a href="#" class="demo author" data-author="hypar" data-url="Origami/hypar.svg">Hypar</a></li>
                            <li><a href="#" class="demo author" data-author="hypar" data-url="Origami/6ptHypar-anti.svg">Hypar (6 point)</a></li>
                            <li><a href="#" class="demo" data-url="Origami/singlesquaretwist.svg">Square Twist (single)</a></li>
                            <li><a href="#" class="demo author" data-author="squareTwist" data-url="Origami/squaretwistManyAngles.svg">Square Twist (many angles)</a></li>
                            <li><a href="#" class="demo author" data-author="moosersTrain" data-url="Origami/MoosersTrainRigid-Gardner.svg">Mooser's Rigid Train</a></li>
                            <li><a href="#" class="demo author" data-author="pakin" data-url="Origami/airplane.svg">Paper Airplane</a></li>
                            <li class="divider"></li>
                            <li><a href="#" class="demo author" data-author="langTreemaker" data-url="Origami/langCardinal.svg">Lang Cardinal</a></li>
                            <li><a href="#" class="demo author" data-author="langTreemaker" data-url="Origami/langOrchid.svg">Lang Orchid</a></li>
                            <li><a href="#" class="demo author" data-author="langTreemaker" data-url="Origami/langKnlDragon.svg">Lang KNL Dragon</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Tessellations<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo author" data-author="miuraOri" data-url="Tessellations/miura-ori.svg">Miura-Ori</a></li>
                            <li><a href="#" class="demo author" data-author="miuraOri" data-url="Tessellations/miura_sharpangle.svg">Miura-Ori (sharp angle)</a></li>
                            <li><a href="#" class="demo" data-url="Tessellations/waterbomb.svg">Waterbomb</a></li>
                            <li><a href="#" class="demo author" data-author="whirlpool" data-url="Tessellations/whirlpool.svg">Whirlpool Spiral</a></li>
                            <li><a href="#" class="demo author" data-author="gardner" data-url="Tessellations/FTpoly7.svg">Flower Tower (flat foldable)</a></li>
                            <li><a href="#" class="demo author" data-author="fellerSmocked" data-url="Tessellations/HexTriFlatFoldableTess.svg">Hex/Tri Tessellation (flat foldable)</a></li>
                            <li class="divider"></li>
                            <li><a href="#" class="demo author" data-author="huffmanTessellations" data-url="Tessellations/huffmanExtrudedBoxes.svg">Huffman Extruded Boxes</a></li>
                            <li><a href="#" class="demo author" data-author="huffmanTessellations" data-url="Tessellations/huffmanWaterbomb.svg">Huffman Waterbombs</a></li>
                            <li><a href="#" class="demo author" data-author="huffmanTessellations" data-url="Tessellations/huffmanRectangularWeave.svg">Huffman Rect Weave</a></li>
                            <li><a href="#" class="demo author" data-author="huffmanTessellations" data-url="Tessellations/huffmanStarsTriangles.svg">Huffman Stars-Triangles</a></li>
                            <li><a href="#" class="demo author" data-author="huffmanTessellations" data-url="Tessellations/huffmanExdentedBoxes.svg">Huffman Exdented Boxes</a></li>
                            <li class="divider"></li>
                            <li><a href="#" class="demo author" data-author="langTessellations" data-url="Tessellations/langHoneycomb.svg">Lang Honeycomb Tessellation</a></li>
                            <li><a href="#" class="demo author" data-author="langTessellations" data-url="Tessellations/langWedgeDoubleFaced.svg">Lang Wedged Double Faced Tessellation</a></li>
                            <li><a href="#" class="demo author" data-author="langTessellations" data-url="Tessellations/langOvalTessellation.svg">Lang Oval Tessellation</a></li>
                            <li><a href="#" class="demo author" data-author="langTessellations" data-url="Tessellations/langHyperbolicLimit.svg">Lang Hyperbolic Limit</a></li>
                            <li class="divider"></li>
                            <li><a href="#" class="demo author" data-author="reschTessellations" data-url="Tessellations/reschTriTessellation.svg">Resch Triangle Tessellation</a></li>
                            <li><a href="#" class="demo author" data-author="reschTessellations" data-url="Tessellations/reschBarbell.svg">Resch Barbell Tessellation</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Curved Creases<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <!-- Using class "cc" causes the example to be loaded with the curved crease checkbox enabled -->
                            <!-- Some examples already have rulings drawn in and don't need the cc importer -->
                            <li><a href="#" class="demo author cc" data-author="mitani" data-url="Curved/wavy_pleats.svg">Wavy Pleats</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitaniCCbook" data-url="Curved/Tri-Wing_Boomerang_Tiling.svg">Boomerang Tessellation</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitani3Dbook" data-url="Curved/Origami_Sphere_16Flaps.svg">Origami Sphere</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitani" data-url="Curved/comet.svg">Comet</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitani" data-url="Curved/scale.svg">Scale Tessellation</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitaniCCbook" data-url="Curved/Carved_Cylinder.svg">Carved Cylinder</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitaniCCbook" data-url="Curved/Rotating_Star.svg">Rotating Star</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitaniCCbook" data-url="Curved/Crossing_curves.svg">Crossing Curves</a></li>
                            <li><a href="#" class="demo author cc" data-author="mitaniCCbook" data-url="Curved/Treble_Clef.svg">Treble Clef</a></li>
                            <li class="divider"></li>
                            <li><a href="#" class="demo author cc" data-author="lukashevaCCbook" data-url="Curved/Leafy_Opus_T-69.svg">Leafy (Opus T-69)</a></li>
                            <li><a href="#" class="demo author cc" data-author="lukasheva" data-url="Curved/Sweet_Dreams_Opus_T-41.svg">Sweet Dreams (Opus T-41)</a></li>
                            <li><a href="#" class="demo author cc" data-author="lukasheva" data-url="Curved/Improvisation-62.svg">Improvisation 62</a></li>
                            <li class="divider"></li>
                            <li><a href="#" class="demo author" data-author="huffmanCurved" data-url="Curved/huffmanTower.svg">Huffman Tower</a></li>
                            <li><a href="#" class="demo author cc" data-author="fellerKwan" data-url="Curved/HexSpiralTess.svg">Hex Spiral Tessellation</a></li>
                            <li><a href="#" class="demo" data-url="Curved/CircularPleat-antiFacet.svg">Circular Pleat</a></li>
                            <li><a href="#" class="demo author" data-author="sam" data-url="Curved/shell14.svg">14 Panel Shell</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Kirigami<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo author" data-author="miyamotoHappy" data-url="Kirigami/miyamotoTower.svg">Miyamoto Tower</a></li>
                            <li><a href="#" class="demo" data-url="Kirigami/honeycombKiri.svg">Kirigami Honeycomb</a></li>
                            <li><a href="#" class="demo author" data-author="milliron" data-url="Kirigami/auxetic_triangle.svg">Auxetic Triangle Tessellation</a></li>
                            <li><a href="#" class="demo author" data-author="kreuter" data-url="Kirigami/triPerfTess.svg">Perforated Triangle Tessellation</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Popups<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo author" data-author="ullagami" data-url="Popup/geometricPopup.svg">Geometric Pattern</a></li>
                            <li><a href="#" class="demo author" data-author="popupology" data-url="Popup/castlePopup.svg">Castle</a></li>
                            <li><a href="#" class="demo author" data-author="popupology" data-url="Popup/housePopup.svg">House</a></li>
                            <!--<li><a href="#" class="demo" data-url="Popup/popupSimple.svg">Simple Square</a></li>-->
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Maze Foldings<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo author" data-author="squareMaze" data-url="Squaremaze/helloworld.svg">Square Maze "hello world"</a></li>
                            <li><a href="#" class="demo author" data-author="squareMaze" data-url="Squaremaze/origamisimulator.svg">Square Maze "origami simulator"</a></li>
                            <li><a href="#" class="demo author" data-author="squareMaze" data-url="Squaremaze/cross.svg">Square Maze "+"</a></li>
                            <li class="divider"></li>
                            <li><a href="#" class="demo author" data-author="polygami" data-url="Polygami/polygamiCross.svg">Polygami "+"</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Pleating<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo author" data-author="konjevod" data-url="Pleating/BoxPleatPyramid.fold">Box Pleat Pyramid</a></li>
                            <li><a href="#" class="demo author" data-author="konjevod" data-url="Pleating/BoxPleatSpiralPyramid.fold">Box Pleat Spiral Pyramid</a></li>
                            <li><a href="#" class="demo author" data-author="konjevod" data-url="Pleating/BoxPleatInOutWave.fold">Box Pleat In Out Wave</a></li>
                            <li><a href="#" class="demo author" data-author="konjevod" data-url="Pleating/BoxPleatSkipOneWave.fold">Box Pleat Skip One Wave</a></li>
                            <li><a href="#" class="demo author" data-author="konjevod" data-url="Pleating/BoxPleatTessellation.fold">Box Pleat Tessellation</a></li>
                            <li><a href="#" class="demo author" data-author="konjevod" data-url="Pleating/BoxPleatTessellationLarge.fold">Box Pleat Tessellation (large)</a></li>
                        </ul>
                    </li>
                    <li class="divider"></li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Origami Bases<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo" data-url="Bases/birdBase.svg">Bird Base</a></li>
                            <li><a href="#" class="demo author" data-author="moveSlowly" data-url="Bases/frogBase.svg">Frog Base</a></li>
                            <li><a href="#" class="demo" data-url="Bases/boatBase.svg">Boat Base</a></li>
                            <li><a href="#" class="demo" data-url="Bases/pinwheelBase.svg">Pinwheel Base</a></li>
                            <li><a href="#" class="demo" data-url="Bases/openSinkBase.svg">Open Sink Base</a></li>
                            <li><a href="#" class="demo" data-url="Bases/squareBase.svg">Square Base</a></li>
                            <li><a href="#" class="demo" data-url="Bases/waterbombBase.svg">Waterbomb Base</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Simple Folds<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo" data-url="SimpleFolds/simpleVertex.svg">Simple Vertex</a></li>
                            <li><a href="#" class="demo" data-url="SimpleFolds/russianTriangle.svg">Russian Triangle</a></li>
                            <li><a href="#" class="demo" data-url="SimpleFolds/mapfold.svg">Map Fold</a></li>
                            <li><a href="#" class="demo" data-url="SimpleFolds/brochurefold.svg">Brochure Fold</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Bistable<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo author" data-author="bistable" data-url="Bistable/curvedPleatSimple.svg">Curved Pleat</a></li>
                        </ul>
                    </li>
                    <li class="divider"></li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Problematic Patterns<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" class="demo author" data-author="skinnyTriangles" data-url="Tessellations/langRattanWeave.svg">Lang Rattan Weave</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li class="dropdown navDropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">View <b class="caret"></b></a>
                <span class="dropdown-arrow"></span>
                <ul class="dropdown-menu">
                    <!--<li><a id="menuVis" href="#">Toggle Menu Visibility</a></li>-->
                    <li><a id="changeBackground" href="#">Change Background Color...</a></li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">Rotate Model<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a id="stopRotation" href="#">Stop Rotation</a></li>
                            <li><a id="rotateX" href="#">Rotate Around X</a></li>
                            <li><a id="rotateY" href="#">Rotate Around Y</a></li>
                            <li><a id="rotateZ" href="#">Rotate Around Z</a></li>
                            <li><a id="changeRotationSpeed" href="#">Change Rotation Speed...</a></li>
                        </ul>
                    </li>
                    <li class="dropdown-submenu">
                        <a tabindex="-1">View Direction<span class="pull-right fui-arrow-right"></span></a>
                        <ul class="dropdown-menu">
                            <li><a href="#" id="cameraZ">View Front</a></li>
                            <li><a href="#" id="cameraMinusZ">View Back</a></li>
                            <li><a href="#" id="cameraX">View Right</a></li>
                            <li><a href="#" id="cameraMinusX">View Left</a></li>
                            <li><a href="#" id="cameraY">View Top</a></li>
                            <li><a href="#" id="cameraMinusY">View Bottom</a></li>
                            <li><a href="#" id="cameraIso">View Iso</a></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><a id="navPattern" href="#">Pattern</a></li>
            <li><a id="navSimulation" href="#">Simulation</a></li>
            <li><a id="about" class="menuHoverControls" target="_blank" href="#">About</a></li>
			
        </ul>
		 <ul class="nav navbar-nav navbar-right">
			<a href="#" class="menuHoverControls" id="showAdvancedOptions">Options</a>
		 </ul>
        <!--<form class="navbar-form navbar-right" action="#" role="search">-->
            <!--<div class="form-group">-->
              <!--<div class="input-group">-->
                <div class="sliderInput floatRight" id="creasePercentNav">
                    <span class="label-slider">Fold Percent : </span><div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
                    <!--<input value="" placeholder="" class="form-control" type="text">-->
                </div>
              <!--</div>-->
            <!--</div>-->
        <!--</form>-->

    </div><!-- /.navbar-collapse -->
    <input id="fileSelector" type="file">

</nav>

<div  id="threeContainer"></div>
<canvas id="gpuMathCanvas"></canvas>
<div id="basicUI">
    <!--<div class="inlineBlock fullWidth">-->
        <!--<a class="about" href="#" id="aboutUserInteraction"><span class="fui-question-circle"></span></a>-->
        <!--<label style="margin-right:40px" class="checkbox floatRight" for="userInteractionEnabled">-->
            <!--<input id="userInteractionEnabled" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>-->
            <!--Allow User Interaction-->
        <!--</label>-->
    <!--</div><br/><br/>-->
    <!-- <a href="#" id="showAdvancedOptions">Show Advanced Options</a><br/><br/> -->

</div>

<div id="controls">
    <a href="#" id="hideAdvancedOptions">Hide Options</a><br/><br/>
    <div class="sliderInput floatRight" id="creasePercent">
        <span class="label-slider">Fold Percent : </span><div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
        <input value="" placeholder="" class="float form-control" type="text">&nbsp;&nbsp;%
    </div><br/><br/>
    <!--<b>Simulation Type:</b><br/>-->
    <!--<div class="indent">-->
        <!--<label class="radio">-->
            <!--<input name="simType" value="dynamic" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>-->
            <!--Compliant Dynamic Simulation <a class="about floatRight" href="#" id="aboutDynamicSim"><span class="fui-question-circle"></span></a>-->
        <!--</label>-->
        <!--&lt;!&ndash;<label class="radio">&ndash;&gt;-->
            <!--&lt;!&ndash;<input name="simType" value="static" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>&ndash;&gt;-->
            <!--&lt;!&ndash;Compliant Static Simulation <a class="about floatRight" href="#" id="aboutStaticSim"><span class="fui-question-circle"></span></a>&ndash;&gt;-->
        <!--&lt;!&ndash;</label>&ndash;&gt;-->
        <!--&lt;!&ndash;<label class="radio">&ndash;&gt;-->
            <!--&lt;!&ndash;<input name="simType" value="rigid" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>&ndash;&gt;-->
            <!--&lt;!&ndash;Rigid Static Simulation <a class="about floatRight" href="#" id="aboutRigidSim"><span class="fui-question-circle"></span></a>&ndash;&gt;-->
        <!--&lt;!&ndash;</label>&ndash;&gt;-->
    <!--</div><br/>-->
    <div class="inlineBlock fullWidth">
        <a class="about" href="#" id="aboutUserInteraction"><span class="fui-question-circle"></span></a>
        <label style="margin-right:40px" class="checkbox floatRight" for="userInteractionEnabled">
            <input id="userInteractionEnabled" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
            Allow User Interaction
        </label>
    </div><br/>
    <div id="simButtons" class="alignRight">
        <a href="#" id="start" class="paddingBottom btn btn-lg btn-success">Start Simulation</a>
        <a href="#" id="pause" class="paddingBottom btn btn-lg btn-warning">Pause Simulation</a>
        <a href="#" id="reset" class="paddingBottom btn btn-lg btn-default">Reset</a>
    </div>
    <div class="fullWidth">
        <a href="#" class="seeMore closed" data-id="simulationSettings"><span class="fui-triangle-down"></span><b>Simulation Settings:</b></a><a class="about" href="#" id="aboutStiffness"><span class="fui-question-circle"></span></a><br/>
        <div id="simulationSettings" class="hide">
            <div class="indent">Numerical Integration:
            <div class="doubleIndent">
                <label class="radio">
                    <input name="integrationType" value="euler" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Euler (first order)
                </label>
                <label class="radio">
                    <input name="integrationType" value="verlet" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Verlet (second order)
                </label>
            </div></div><br/>
            <div class="sliderInput paddingBottom" id="axialStiffness">
                <span class="label-slider">Axial Stiffness : </span><div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
                <input value="" placeholder="" class="float form-control" type="text">
            </div>
            <div class="sliderInput paddingBottom" id="faceStiffness">
                <span class="label-slider">Face Stiffness : </span><div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
                <input value="" placeholder="" class="float form-control" type="text">
            </div>
            <div class="sliderInput" id="creaseStiffness">
                <span class="label-slider">Fold Stiffness : </span><div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
                <input value="" placeholder="" class="float form-control" type="text">
            </div>
            <div class="sliderInput" id="panelStiffness">
                <span class="label-slider">Facet Crease Stiffness : </span><div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
                <input value="" placeholder="" class="float form-control" type="text">
            </div>
            <div class="sliderInput" id="percentDamping">
                <span class="label-slider">Damping Ratio : </span><div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
                <input value="" placeholder="" class="float form-control" type="text">
            </div>
        </div><br/>
    </div>
    <div class="fullWidth">
        <a href="#" class="seeMore closed" data-id="animationsSettings"><span class="fui-triangle-down"></span><b>Animation Settings:</b></a><a class="about" href="#" id="aboutAnimation"><span class="fui-question-circle"></span></a><br/>
        <div id="animationsSettings" class="fullWidth hide">
            <div class="doubleIndent">
                <span class="smallTxt">&Delta;t = <span id="deltaT"></span> seconds</span><br/>
                <span class="smallTxt">Num simulation steps per frame: &nbsp;&nbsp;<input value="" placeholder="" class="numStepsPerRender int form-control" type="text"></span><br/><br/>
                <div id="stepForwardOptions" class="floatRight">
                    <a href="#" id="stepForward" class="floatRight btn btn-lg btn-default">Step Forward</a><br/><br/>
                </div>
                <div class="fullWidth alignRight">
                    <a href="#" id="shouldCenterGeo" class="displayBlock btn btn-lg btn-default">Re-center geometry</a>
                </div>
            </div>
        </div>
    </div><br/>

    <div class="fullWidth">
        <a href="#" class="seeMore closed" data-id="errorInfo"><span class="fui-triangle-down"></span><b>Error:</b></a><a class="about" href="#" id="aboutError"><span class="fui-question-circle"></span></a><br/>
        <div id="errorInfo" class="hide smallTxt doubleIndent">
            <label>Average vertex error: <span id="globalError"></span></label>
        </div>
    </div><br/>

    <div class="extraSpace"></div>
</div>
<div id="svgViewer"></div>

<div id="controlsBottom" style="display: flex; align-items: center; justify-content: center; width: 100%;">
    <!-- <div id="viewToggle" class="bigToggle">
        <div>
            <a href="#" id="colorToggle"><div class="active"><img src="assets/hyparColorSmall.png"/><span>Material</span></div></a><div class="separator"></div><a href="#" id="strainToggle"><div><img src="assets/hyparStrainSmall.png"/><span>Strain</span></div></a>
        </div>
        View Mode
    </div> -->
    <div id="bottomSliderContainer" style="display: flex; align-items: center;">
        <div class="sliderInput" id="creasePercentBottom">
            <div class="flat-slider ui-slider ui-corner-all ui-slider-horizontal ui-widget ui-widget-content"></div>
        </div>
        <a href="#" id="flatIndicator" class="sliderEndPt smallTxt">
            <!--<img src="assets/flatcraneSmall.png"/>-->
            <!-- <span class="sliderEndPtLabel">Flat</span> -->
            <!-- <span class="fui-triangle-down"></span> -->
        </a>
        <a href="#" id="foldedIndicator" class="sliderEndPt smallTxt">
            <!--<img src="assets/foldedCraneSmall.png"/>-->
            <!-- <span class="sliderEndPtLabel">Folded</span> -->
            <!-- <span class="fui-triangle-down"></span> -->
        </a>
        <span><span id="foldPercentSimple" style="display:none;"></span></span>
    </div>
    <div id="bottomButtonContainer" style="position:absolute; right:0px;display: flex; gap: 20px; margin-left: 40px; ">
        <a href="#" id="dlButton" style="font-size: 10px; cursor: pointer; font-weight: 500;"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16">
  <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/>
  <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/>
</svg></a>
        <a href="#" id="printButton" style="font-size: 10px; cursor: pointer; font-weight: 500;"><svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" fill="currentColor" class="bi bi-printer" viewBox="0 0 16 16">
  <path d="M2.5 8a.5.5 0 1 0 0-1 .5.5 0 0 0 0 1"/>
  <path d="M5 1a2 2 0 0 0-2 2v2H2a2 2 0 0 0-2 2v3a2 2 0 0 0 2 2h1v1a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2v-1h1a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2h-1V3a2 2 0 0 0-2-2zM4 3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v2H4zm1 5a2 2 0 0 0-2 2v1H2a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v-1a2 2 0 0 0-2-2zm7 2v3a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1"/>
</svg></a>
    </div>
    <!-- <div id="controlsToggle" class="bigToggle">
        <div>
            <a href="#" id="orbitToggle"><div class="active"><img class="preserveAspect" src="assets/rotateSmall.png"/><span>Rotate</span></div></a><div class="separator"></div><a href="#" id="grabToggle"><div><img class="preserveAspect" src="assets/grabSmall.png"/><span>Grab</span></div></a>
        </div>
        Control Mode
    </div>
    <a href="#" id="resetBottom" class="btn btn-lg btn-default">Reset</a> -->
</div>
<div id="controlsLeft" class="flipped">
    <div>
        <b>View Settings:</b><br/><br/>
        <div class="indent">
            <div>
                <a href="#" class="seeMore open" data-id="materialSettings"><span class="fui-triangle-down"></span>Mesh Material:</a>
            </div>
            <div id="materialSettings" class="inlineBlock indent">
                <label class="checkbox" for="meshVisible">
                    <input id="meshVisible" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Mesh Visible
                </label>
                <div id="meshMaterialOptions">
                    <label class="radio">
                        <input name="colorMode" value="color" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Colored Material
                    </label>
                    <div id="coloredMaterialOptions" class="indent">
                        <label>Color 1 (rgb hex): &nbsp;&nbsp;</label><input id="color1" value="" placeholder="" class="hexVal form-control" type="text"><br/>
                        <label>Color 2 (rgb hex): &nbsp;&nbsp;</label><input id="color2" value="" placeholder="" class="hexVal form-control" type="text"><br/>
                    </div>
                    <label class="radio">
                        <input name="colorMode" value="axialStrain" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Strain Visualization<a class="about floatRight" href="#" id="aboutAxialStrain"><span class="fui-question-circle"></span></a>
                    </label>
                    <div id="axialStrainMaterialOptions" class="indent">
                        <label>Max Strain: &nbsp;&nbsp;</label>
                        <input id="strainClip" value="" placeholder="" class="float form-control" type="text"> %<br/>
                    </div>
                    <label class="radio">
                        <input name="colorMode" value="normal" data-toggle="radio" class="custom-radio" type="radio"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Face Normals Material
                    </label>
                    <label class="radio">
                        <input name="colorMode" value="texture" data-toggle="radio" class="custom-radio" type="radio" checked><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Texture Material
                    </label>
                    <div id="textureMaterialOptions" class="indent">
                        <label>Load Multiple Textures: &nbsp;&nbsp;</label>
                        <input id="textureFileInput" type="file" accept="image/png,image/jpg,image/jpeg,image/avif,image/webp,image/gif" multiple class="form-control" style="width: 250px;"><br/>
                        <span class="smallTxt">Select multiple images (PNG/JPG/AVIF/WebP/GIF). Large files will be automatically optimized. Images will be randomly distributed across faces.</span><br/>
                        <div id="compressionStatus" style="margin: 5px 0; font-size: 12px; color: #007cff;"></div>
                        <div id="textureList" style="max-height: 150px; overflow-y: auto; margin: 10px 0;"></div>
                        <label>Default Texture Repeat: &nbsp;&nbsp;</label>
                        <input id="textureRepeat" value="1.0" placeholder="1.0" class="float form-control" type="text" style="width: 80px;"><br/>
                        <label class="checkbox" for="randomTextures">
                            <input id="randomTextures" data-toggle="checkbox" class="custom-checkbox" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                            Randomly assign textures to faces
                        </label><br/>
                        <span class="smallTxt">🎨 Multiple textures: Images are automatically distributed across origami faces. Random assignment is enabled by default when multiple images are loaded.</span>
                        
                        <!-- Random Seed Control -->
                        <div style="margin-top: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
                            <label style="font-weight: bold; color: #2c3e50;">🎲 Random Seed Control:</label><br/>
                            <div style="display: flex; align-items: center; margin-top: 5px;">
                                <input id="randomSeed" value="origami-simulator-2024" placeholder="Enter seed..." class="form-control" type="text" style="width: 200px; margin-right: 10px;">
                                <button id="applyRandomSeed" class="btn btn-primary btn-sm" onclick="applyRandomSeed()">Apply Seed</button>
                                <button id="resetRandomSeed" class="btn btn-secondary btn-sm" onclick="resetRandomSeed()" style="margin-left: 5px;">Reset</button>
                            </div>
                            <span class="smallTxt" style="color: #7f8c8d;">🔑 Set a custom seed to make random operations deterministic. Same seed = same results.</span>
                        </div>
                    </div>
                </div>
                <br/>
            </div><br/>
            <div>
                <a href="#" class="seeMore closed" data-id="edgeVisibility"><span class="fui-triangle-down"></span>Edge Visibility</a>:
            </div>
            <div id="edgeVisibility" class="hide indent">
                <label class="checkbox" for="edgesVisible">
                    <input id="edgesVisible" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Edges Visible
                </label>
                <div id="edgeVisOptions" class="indent">
                    <label class="checkbox" for="mtnsVisible">
                        <input id="mtnsVisible" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Mountains <span id="numMtns"></span>
                    </label>
                    <label class="checkbox" for="valleysVisible">
                        <input id="valleysVisible" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Valleys <span id="numValleys"></span>
                    </label>
                    <label class="checkbox" for="panelsVisible">
                        <input id="panelsVisible" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Facet Creases <span id="numFacets"></span>
                    </label>
                    <label class="checkbox" for="passiveEdgesVisible">
                        <input id="passiveEdgesVisible" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Undriven Edges <span id="numPassive"></span>
                    </label>
                    <label class="checkbox" for="boundaryEdgesVisible">
                        <input id="boundaryEdgesVisible" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        Boundary Edges <span id="numBoundary"></span>
                    </label>

                </div>
                <br/>
            </div>
            <br/>
            <!--Rendering:-->
            <!--<div class="indent">-->
                <!--<label class="checkbox" for="ambientOcclusion">-->
                    <!--<input id="ambientOcclusion" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>-->
                    <!--Ambient Occlusion-->
                <!--</label>-->
            <!--</div>-->
            <div>
                <a href="#" class="seeMore closed" data-id="virtualReality"><span class="fui-triangle-down"></span>Virtual Reality:</a><a class="about floatRight" href="#" id="aboutVR"><span class="fui-question-circle"></span></a>
            </div>
            <div id="virtualReality" class="hide indent smallTxt">
                <b>Status:</b> &nbsp;<span id="VRstatus"></span>
                <div id="VRoptions"><br/>
                    <a href="#" id="enterVR" class="displayBlock btn btn-lg btn-inverse"></a>
                </div><br/><br/>
            </div><br/>
            <div class="extraSpace"></div>
        </div>
    </div>
</div>

<div class="modal fade" id="tipsModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>DESIGN TIPS</b><br/><br/>
                    Bad design files will throw errors and create models that explode or cannot be solved, here are some tips for
                    importing FOLD or SVG files that work.<br/><br/>
                    <b>Importing FOLD:</b><br/><br/>
                    The FOLD file format is specified in <a target="_blank" href="https://github.com/edemaine/fold">these docs</a>.
                    This tool imports FOLD v1.0 files with <b>all</b> of the following fields populated:
                    <ul>
                        <li>vertices_coords</li>
                        <li>edges_vertices</li>
                        <li>edges_assignment</li>
                        <li>faces_vertices</li>
                    </ul>
                    You may specify the target fold angle of each crease using the edges_foldAngle field. 
                    Note that fold angle is a number in degrees lying in the range [−180, 180]. 
                    The fold angle is positive for valley folds, negative for mountain folds, and zero for flat regions.
                    Accordingly, the sign of edges_foldAngle should match edges_assignment if both are specified.
                    You may also assign a null fold angle to a crease so that it is allowed to move freely - this is especially useful when the fold angle is unknown or the crease pattern is fully constrained and able to be driven by other creases in the system.
                    <br/><br/>
                    If you are unsure whether your FOLD file is valid, you can inspect it using the
                    <a target="_blank" href="https://edemaine.github.io/fold/examples/foldviewer.html">FOLD Viewer</a>. 
                    If you are having trouble, please refer to the <a target=_blank href="https://github.com/edemaine/fold/blob/master/doc/spec.md">FOLD spec</a>.
                    <br/><br/>
                    <b>Importing SVG:</b><br/><br/>
                    <ul>
                        <li>The SVG importer supports path, line, rect, polygon, and polyline objects with the appropriate
                            stroke color:</li>
                        <li>Mountain folds have <b style="color:red">red</b> stroke - rgb(255, 0, 0), hex #ff0000</li>
                        <li>Valley folds have <b style="color:blue">blue</b> stroke - rgb(0, 0, 255), hex #0000ff</li>
                        <li>Boundary edges have <b style="color:black">black</b> stroke - rgb(0, 0, 0), hex #000000 - use
                        this edge type for both the outline of the pattern, and any internal holes.</li>
                    </ul>
                        <object type="image/svg+xml" data="assets/doc/simplePatterns.svg">
                          Your browser does not support SVG
                        </object>
                    <ul>
                        <li>The final fold angle of a mountain or valley fold is set by its opacity. For example, 1.0 = 180&deg;
                        (fully folded), 0.5 = 90&deg;, 0 = 0&deg; (flat).  Any fold angle between  0&deg; and 180&deg; may be used.  The following
                            patterns contain creases with varying final fold angles:
                        </li>
                    </ul>
                        <object type="image/svg+xml" data="assets/doc/opacityExamples.svg">
                          Your browser does not support SVG
                        </object>
                    <ul>
                        <li>Before the model can enter the simulator, this tool will automatically triangulate regions in the pattern that form polygons with more than three sides.
                        To control the triangulations, draw lines in <b style="color:#cccc00">yellow</b> - rgb(255, 255, 0), hex #ffff00.  In general, patterns are more stable when their triangulation is symmetric and minimizes long, skinny triangles.  You can see
                        how the app automatically triangulated your pattern by enabling "Facet Crease" visibility in the <b>Advanced Options > Edges Visibility</b>
                            menu on the left side of the screen.  It may not be necessary to add triangulation lines on your pattern.</li>
                    </ul>
                        <object type="image/svg+xml" data="assets/doc/triangulations.svg">
                          Your browser does not support SVG
                        </object>
                    <ul>
                        <li>Facet creases (yellow triangulation lines) are creases that try to remain flat (0&deg; fold angle) as the pattern folds, but some compliance
                            in the constraints of the simulation will allow them to bend slightly.  Drawing in facet creases allows you to control
                            the way the model bends in between mountain/valley folds.  This is especially relevant in patterns with curved creases.
                            If you import an svg with bezier curves and select the checkbox "crease pattern contains curves" in the import dialog, we attempt to triangulate it for you using the algorithm described by <a href="http://www.cgg.cs.tsukuba.ac.jp/projects/2020/RulingAwareTriangulation/index.html" target="_blank">Simple Simulation of Curved Folds Based on Ruling-aware Triangulation</a>.
                            We recommend trying this first, and add additional facet creases to your svg design where needed.
                        </li>
                    </ul>
                        <object type="image/svg+xml" data="assets/doc/triangulationsCurved.svg">
                          Your browser does not support SVG
                        </object>
                    <ul>
                        <li>Cuts have <b style="color:#00ff00">green</b> stroke - rgb(0, 255, 0), hex #00ff00 - use this edge type
                        to form thin slits in the pattern.</li>
                    </ul>
                        <object type="image/svg+xml" data="assets/doc/cuts.svg">
                          Your browser does not support SVG
                        </object>
                    <ul>
                        <li>Undriven creases have <b style="color:magenta">magenta</b> stroke - rgb(255, 0, 255), hex #ff00ff -
                        creases of this type will swing freely.  Use this crease type when you're not sure what angle some of the
                        creases in your pattern should fold to.</li>
                    </ul>
                        <object type="image/svg+xml" data="assets/doc/hinges.svg">
                          Your browser does not support SVG
                        </object>
                    <ul>
                        <li>Line style and stroke width do not matter.</li>
                        <li>Remove clipping masks from your file before importing.</li>
                        <li>This tool should be able to automatically clean files of slightly misaligned vertices, stray vertices,
                        duplicate lines, and extra vertices falling in the middle of an edge,
                        but it is recommended to remove these errors yourself in order to avoid problems.</li>
                        <li>If your simulation is not working, check that the imported pattern looks correct by clicking on the <b>Pattern</b> view in the top nav bar.
                        You can also download a copy of the imported pattern ( <b>File > Save Pattern as SVG</b> ) and view it in a vector
                        editing program of your choice.</li>
                    </ul><br/>

                <b>For Adobe Illustrator users:</b><br/><br/>
                I use Illustrator to create SVGs (though any vector editing program should be fine).  Here are some tips I've found for making svgs to import into this tool.<br/><br/>
                    <ul>
                        <li>If you are starting with a pre-made vector file, first release all clipping masks (<b>Select all + Object > Clipping Mask > Release</b>).</li>
                        <li>Create geometry using the <b>Line Segment</b>, <b>Rectangle</b>,  and <b>Polygon</b> tools.</li>
                        <li>Illustrator can help you select all lines of a particular type so that you can edit their color or opacity together.  Click the line,
                        then go to <b>Select > Same > Appearance</b> to select all similar lines in the pattern.
                        <li>Be sure that <b>CSS Properties</b> is set to <b>Presentation Attributes</b> in the Advanced options.
                        <li>Finally hit <b>Save As</b> and select <b>.svg</b> extension. I'm using the default SVG 1.1 settings, but version 1.0 will work as well.</li>
                    </ul>
                <img style="width:100%" src="assets/doc/illustratorSaveOptions.jpg"/>
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutVRmodal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>VIRTUAL REALITY</b><br/><br/>
                This tool currently supports an interactive Virtual Reality mode for the Vive and Oculus headset and controllers (it may work on others, but it is not tested).
                For this to work, you must first use a <a href="https://webvr.info/" target="_blank">WebVR enabled browser</a>:
                currently only <a href="https://webvr.info/get-chrome/" target="_blank">an experimental build of Chromium</a> (with enable-webvr and
                        -enable-gamepad-extensions flags) and <a href="https://webvr.rocks/firefox" target="_blank">the latest Firefox for Windows </a>
                      are supported by this app.
                <br/><br/>
                    When you open this page with the appropriate browser, you will see a button that says "<b>ENTER VR</b>".  Clicking this will
                put the app into an interactive VR mode.  The hand controllers will allow you to grab the origami mesh and pull on it.
                This is especially interesting if you set the <b>Mesh Material</b> to <b>Strain Visualization</b> so you can see how your interactions
                change the internal strains in the material.
                <br/><br/>
                    <b>Troubleshooting</b>:<br/>
                <ul>
                    <li>If the simulation looks choppy, consider lowering the <b>Animation Settings > Num Steps Per Frame</b> setting.</li>
                    <li>The origami should load up in the center of your playspace.  If things load way off in the distance, you may need to reboot your headset and controllers and refresh this app.  I do this through SteamVR.</li>
                    <li>If you hand controllers are not appearing, try clicking the System Button (Vive) to get them to wake up.  If you still have trouble connecting, try refreshing this app.</li>
                    <li>WebVR is changing rapidly, if you cannot connect be sure you have the latest browser version and install any firmware updates on your headset, controllers, and sensors.</li>
            </ul>
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutAnimationModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>ANIMATION SETTINGS</b><br/><br/>
                The dynamic simulation is calculated by solving for all the forces in the system, moving time forward in small <b>&Delta;t</b> steps,
                and updating the vertices of the origami incrementally.  The time step size for this animation is calculated automatically
                based on the material stiffnesses set in the <b>Simulation Settings</b> section: more stiff settings
                require shorter time steps to solve and will slow down the simulation.<br/>
                <br/>
                <b>Num simulation steps per frame</b> allows you to control the number of tiny time steps forward to take on each
                render cycle.  If the simulation looks choppy to you, you might consider lowering this setting.
                Lowering the number of steps per frame will slow down the simulation, but will result in a more smooth animation.
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="exportSTLModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <b>EXPORT STL</b><br/><br/>
                Filename: &nbsp;&nbsp;<input id="stlFilename" value="" placeholder="" class="bigInput text form-control" type="text"> .stl<br/><br/>
                Scale: &nbsp;&nbsp;<input value="" placeholder="" class="float exportScale form-control" type="text"><br/><br/>
                Dimensions: &nbsp;&nbsp;<b><span class="exportDimensions"></span></b><br/>
                <span class="smallTxt">( the STL file format is unitless, but typically assumed to be either in inches or mm )</span><br/>
                <label class="bigLabel checkbox" for="doublesidedSTL">
                    <input id="doublesidedSTL" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Double Sided
                </label>
            </div>
            <div class="modal-footer">
                <button id="doSTLsave" type="button" class="actionButton btn btn-success" data-dismiss="modal">Save</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="exportOBJModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <b>EXPORT OBJ</b><br/><br/>
                <span class="smallTxt">These OBJs are compatible with Freeform Origami</span><br/>
                Filename: &nbsp;&nbsp;<input id="objFilename" value="" placeholder="" class="bigInput text form-control" type="text"> .obj<br/><br/>
                Scale: &nbsp;&nbsp;<input value="" placeholder="" class="float exportScale form-control" type="text"><br/><br/>
                Dimensions: &nbsp;&nbsp;<b><span class="exportDimensions"></span></b><br/>
                <span class="smallTxt">( the OBJ file format is unitless, but typically assumed to be either in inches or mm )</span><br/>
                <!--<label class="bigLabel checkbox" for="doublesidedOBJ">-->
                    <!--<input id="polyFacesOBJ" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>-->
                    <!--Allow polygonal faces-->
                <!--</label>-->
                <label class="bigLabel checkbox" for="doublesidedOBJ">
                    <input id="doublesidedOBJ" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Double Sided
                </label>
            </div>
            <div class="modal-footer">
                <button id="doOBJsave" type="button" class="actionButton btn btn-success" data-dismiss="modal">Save</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="exportFOLDModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <b>EXPORT FOLD</b><br/><br/>
                Filename: &nbsp;&nbsp;<input id="foldFilename" value="" placeholder="" class="bigInput text form-control" type="text"> .fold<br/><br/>
                Author: &nbsp;&nbsp;<input id="foldAuthor" value="" placeholder="" class="bigInput text form-control" type="text"><br/><br/>
                Scale: &nbsp;&nbsp;<input value="" placeholder="" class="float exportScale form-control" type="text">&nbsp;&nbsp;&nbsp;&nbsp;
                Units: &nbsp;&nbsp;
                <div class="btn-group">
                    <button data-toggle="dropdown" class="btn btn-default dropdown-toggle" type="button"><span class="unitsDisplay"></span> <span class="caret"></span></button>
                    <ul id="unitsDropdown" role="menu" class="dropdown-menu">
                        <li><a class="units" data-id="unit" href="#">unitless</a></li>
                        <li><a class="units" data-id="in" href="#">in</a></li>
                        <li><a class="units" data-id="pt" href="#">pt</a></li>
                        <li><a class="units" data-id="m" href="#">m</a></li>
                        <li><a class="units" data-id="cm" href="#">cm</a></li>
                        <li><a class="units" data-id="mm" href="#">mm</a></li>
                        <li><a class="units" data-id="um" href="#">um</a></li>
                        <li><a class="units" data-id="nm" href="#">nm</a></li>
                    </ul>
                </div>
                <br/><br/>
                Dimensions: &nbsp;&nbsp;<b><span class="exportDimensions"></span> <span class="unitsDisplay"></span></b><br/>
                <label class="bigLabel checkbox" for="triangulateFOLDexport">
                    <input id="triangulateFOLDexport" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Save with triangulated faces
                </label>
                <label class="bigLabel checkbox" for="exportFoldAngle">
                    <input id="exportFoldAngle" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Save target angles in edges_foldAngle
                </label>
                <span class="smallTxt">For more information about the FOLD file format, see the <a target="_blank" href="https://github.com/edemaine/fold">offical docs</a>.
                Use the <a href="https://edemaine.github.io/fold/examples/foldviewer.html" target="_blank">FOLD viewer</a> to check that your file has been exported correctly.</span>
            </div>
            <div class="modal-footer">
                <button id="doFOLDsave" type="button" class="actionButton btn btn-success" data-dismiss="modal">Save</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="importFoldModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <b>IMPORT FOLD</b><br/><br/>
                <label class="bigLabel checkbox" for="foldUseAngles">
                    <input id="foldUseAngles" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                    Use current angles as target fold angles
                </label>
            </div>
            <div class="modal-footer">
                <button data-dismiss="modal" type="button" class="btn btn-success">OK</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="warningModal" tabindex="-1" role="dialog">
    <div class="modal-dialog sm">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p id="warningMessage"></p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutErrorModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>SIMULATION ERROR</b><br/><br/>
                    <b>Average vertex error</b> gives a sense of how much the distance constraints in the
                    origami pattern are being violated (i.e. how much the sheet is being stretched).  The error at each vertex is evaluated by averaging the
                    percent deviation of all its distance constraints with adjacent vertices.  This error is
                    reported as a percent of the total length of the distance constraint to remove scaling effects.
                    <br/><br/>
                    This measurement is equivalent to <a href="https://en.wikipedia.org/wiki/Deformation_(mechanics)#Engineering_strain" target="_blank">
                        Cauchy strain or engineering strain</a> of the distance constraints on this system.
                    Increasing the <b>Axial Stiffness</b> will tighten these constraints and
                    lower the error in the simulation.<br/>
                    <br/>
                    To visualize the error of each vertex graphically, select <b>Strain Visualization</b> under <b>Mesh Material</b>
                     in the left menu.
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutStiffnessModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>SIMULATION SETTINGS</b><br/><br/>
                    This app uses a compliant dynamic simulation method to solve for the geometry of an origami pattern
                    at a given fold angle.  The simulation sets up several types of constraints: distance constraints prevent the
                    sheet from stretching or compressing, face constraints prevent the sheet from <a href="https://en.wikipedia.org/wiki/Shear_stress" target="_blank">shearing</a>, and angular constraints fold or flatten the sheet.  Each of these constraints is weighted by a stiffness - the stiffer the constraint, the better it is enforced
                    in the simulation.  <br/>
                    <br/>
                    <b>Axial Stiffness</b> is the stiffness of the distance constraints.  Increasing axial
                    stiffness will decrease the stretching/compression (strain) in the simulation, but it will also slow down the solver.
                    <b>Face Stiffness</b> is the stiffness of the face constraints, which help the axial constraints prevent deformation of the sheet's surface between the creases.<br/>
                    <br/>
                    Fold and facet stiffnesses correspond to two types of angular constraints.  <b>Fold Stiffness</b> is the stiffness of the mountain
                    and valley creases in the origami pattern.  <b>Facet Stiffness</b> is the stiffness of the triangulated faces between
                    creases in the pattern.  Increasing facet stiffness causes the faces between creases to stay very flat as the origami is folded.
                    As facet stiffness becomes very high, this simulation approaches a <a href="http://www.tsg.ne.jp/TT/cg/TachiFreeformOrigami2010.pdf" target="_blank">
                        rigid origami simulation</a>, and models the behavior of a rigid material (such as metal) when folded.<br/>
                    <br/>
                    Internally, constraint stiffnesses are scaled by the length of the edge associated with that constraint to determine its <i>geometric stiffness</i>.  For Axial constaints, stiffness is
                    divided by length and for angular constraints, stiffness is multiplied by length.<br/>
                    <br/>
                    Since this is a dynamic simulation, vertices of the origami move with some notion of acceleration and velocity.  In order to
                    keep the system stable and help it converge to a static solution, <a target="_blank" href="https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator">
                        damping</a> is applied to slow the motion of the vertices.  The <b>Damping</b> slider allows you to control the amount of damping
                    present in the simulation.  Decreasing damping makes the simulation more "springy".
                    It may be useful to temporarily turn down damping to help the simulation more quickly converge towards its static solution - especially
                    for patterns that take a long time to curl.<br/>
                    <br/>
                    A <b>Numerical Integration</b> technique is used to integrate acceleration into velocity and position for each time step of the simulation.
                    Different integration techniques have different associated computational cost, error, and stability.  This app allows you to choose
                    between two different integration techniques: <a href="https://en.wikipedia.org/wiki/Euler_method" target="_blank">Euler Integration</a>
                    is the simplest type of numerical integration (first order) with large associated error, and
                    <a href="https://en.wikipedia.org/wiki/Verlet_integration" target="_blank">Verlet Integration</a> is a second order integration technique
                    with lower error and better stability than Euler.
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutDynamicSimModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>COMPLIANT DYNAMIC SIMULATION</b><br/><br/>
                    ....
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutStaticSimModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>COMPLIANT STATIC SIMULATION</b><br/><br/>
                    ....
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutRigidSimModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>RIGID STATIC SIMULATION</b><br/><br/>
                    ....
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutAxialStrainModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                    <p><b>STRAIN VISUALIZATION</b><br/><br/>
                    <a href="https://en.wikipedia.org/wiki/Deformation_(mechanics)#Engineering_strain" target="_blank">
                        Cauchy strain or engineering strain</a> is a unitless measurement of how much a material is being stretched or compressed under load.
                    The <b>Strain Visualization</b> illustrates the strain across an origami sheet by mapping it to a color from blue (no strain) to red (max strain).<br/><br/>
                    <img style="width: 100%;" src="assets/doc/strain.jpg" />
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="aboutUserInteractionModal" tabindex="-1" role="dialog">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                    <p><b>USER INTERACTION</b><br/><br/>
                    Toggle this control to enable/disable mouse interaction with the origami model.  When enabled,
                        mousing over the model will display a highlighter; clicking and dragging allows you to
                        interact with the model in real time.  Very vigorous interactions with the model may cause it
                        to pop into a strange configuration that it can't escape - use the <b>Reset</b> button to start
                        the simulation again from a flat state.
                    </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="changeRotationSpeedModal" tabindex="-1" role="dialog">
    <div class="modal-dialog sm">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>ROTATION SPEED</b><br/><br/>
                    Speed : &nbsp;&nbsp;<input id="rotationSpeed" value="" placeholder="" class="float form-control" type="text"> &nbsp;&nbsp;<span class="smallTxt">( radians per frame )</span>
                </p>
            </div>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="changeBackgroundModal" tabindex="-1" role="dialog">
    <div class="modal-dialog sm">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>BACKGROUND COLOR</b><br/><br/>
                    Color (rgb hex) : &nbsp;&nbsp;<input id="backgroundColor" value="" placeholder="" class="hexVal form-control" type="text"><br/>
                    <span class="smallTxt">Hex colors are 6 digit alphanumeric codes that specify different colors.  You can get these codes using a <a href="https://www.webpagefx.com/web-design/color-picker/" target="_blank">color picker</a>.</span>
                </p>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="importSettingsModal" tabindex="-1" role="dialog">
    <div class="modal-dialog sm">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <p><b>SVG IMPORT SETTINGS</b><br/><br/>
                    Vertex merge tolerance (px) : &nbsp;&nbsp;<input id="vertTol" value="" placeholder="" class="float form-control" type="text">
                    <div class="smallTxt">Vertices within this px tolerance in the SVG will be merged into one.  It is recommended to keep this number above zero.</div>
                </p>
                <!-- for curved folging -->
                <p><b>For curved folding</b>
                    <label class="checkbox" for="curvedLines">
                        <input id="curvedLines" data-toggle="checkbox" class="custom-checkbox layersSelector" type="checkbox"><span class="icons"><span class="icon-unchecked"></span><span class="icon-checked"></span></span>
                        crease pattern contains curves
                    </label>
                    <div class="smallTxt">Check this box if the crease pattern contains curves.</div>
                </p>
                <div id="curvedCreaseImportOptions">
                    <p>
                        Intervals of vertices for discretization (px) : &nbsp;&nbsp;<input id="vertInt" value="" placeholder="" class="float form-control" type="text">
                        <div class="smallTxt">Curves and borderlines are divided into segments by this value. It is recommended to keep this number above zero.</div>
                    </p>
                    <p>
                        Approximation tolerance of curves (px) : &nbsp;&nbsp;<input id="apprCurve" value="" placeholder="" class="float form-control" type="text">
                        <div class="smallTxt">Curves are approximated by polylines. The smaller the value, the higher the quality of the approximation.</div>
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <div id="tipImportSVG" class="smallTxt">Having trouble?  See these <a class="goToImportInstructions" href="#">SVG Import Tips</a>.</div>
                <button id="doSVGImport" type="button" class="actionButton btn btn-success" data-dismiss="modal">Import SVG</button>
            </div>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<div class="modal fade" id="noSupportModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-body">
                This app uses GPU functions that are not supported by this device/browser,
                please try again on desktop with Chrome/Firefox.<br/>
            </div>
        </div>
    </div>
</div>
<div id="authorMoreInfo">
    <div id="authorContent">
        <div id="squareMaze">
            This file was generated by <a href="http://erikdemaine.org/fonts/maze/" target="_blank">Maze Folder</a>,
            an app by <a href="http://erikdemaine.org/" target="_blank">Erik Demaine</a>,
            <a href="http://martindemaine.org/" target="_blank">Martin Demaine</a>,
            and <a href="http://jasonku.mit.edu/" target="_blank">Jason Ku</a> that creates crease patterns for any raised maze on a square grid.
            Based on the paper <a href="http://erikdemaine.org/papers/MazeFolding_Origami5/paper.pdf" target="_blank">Folding Any
            Orthogonal Maze</a> by the same authors.
        </div>
        <div id="huffmanTessellations">
            Designed by <a href="https://en.wikipedia.org/wiki/David_A._Huffman" target="_blank">David Huffman</a>.  Crease pattern adapted from
            the paper <a href="http://erikdemaine.org/papers/HuffmanTess_JMD2013/paper.pdf" target="_blank">Reconstructing David Huffman's Origami Tessellations</a>.
        </div>
        <div id="huffmanCurved">
            Designed by <a href="https://en.wikipedia.org/wiki/David_A._Huffman" target="_blank">David Huffman</a>.  More info about
            Huffman's curved crease folding can be found in the paper <a href="http://erikdemaine.org/papers/Huffman_Origami5/paper.pdf" target="_blank">
            Reconstructing David Huffman’s Legacy in Curved-Crease Folding</a> and the thesis <a href="https://dspace.mit.edu/handle/1721.1/93013" target="_blank">
            Computational design with curved creases : David Huffman's approach to paperfolding</a>.
        </div>
        <div id="reschTessellations">
            Designed by <a href="http://www.ronresch.org/ronresch/" target="_blank">Ron Resch</a>.
        </div>
        <div id="pakin">
            Conventional paper airplane.  Pattern entered by <a href="https://www.pakin.org/~scott" target="_blank">Scott Pakin</a>.
        </div>
        <div id="langTessellations">
            Designed by <a href="http://www.langorigami.com/" target="_blank">Robert Lang</a>.  All original
            crease patterns can be found on <a href="http://www.langorigami.com/crease-patterns" target="_blank">Lang's website</a>.
        </div>
        <div id="langTreemaker">
            Designed by <a href="http://www.langorigami.com/" target="_blank">Robert Lang</a> using <a href="http://www.langorigami.com/article/treemaker" target="_blank">Treemaker</a>.  More info
            about Lang's Treemaker software can be found in the <a href="http://www.langorigami.com/files/articles/TreeMkr40.pdf" target="_blank">Treemaker Manual</a> or in the book
            <a href="http://www.langorigami.com/publication/origami-design-secrets-2nd-edition" target="_blank">Origami Design Secrets</a>.  All original
            crease patterns can be found on <a href="http://www.langorigami.com/crease-patterns" target="_blank">Lang's website</a>.
        </div>
        <div id="moveSlowly">
            Move <b>Fold Percent</b> slowly for this pattern to fold correctly!
        </div>
        <div id="skinnyTriangles">
            When this pattern is triangulated (during the setup of the simulation) it forms many skinny triangles,
            these triangles are very unstable as the pattern folds.
        </div>
        <div id="hypar">
            Alternating asymmetric triangulation of hypar from <a href="http://erikdemaine.org/papers/Hypar_GC/paper.pdf" target="_blank">(Non)existence of Pleated Folds:
            How Paper Folds Between Creases</a>.
        </div>
        <div id="randlett">
            Designed by <a href="https://en.wikipedia.org/wiki/Samuel_Randlett" target="_blank">Samuel Randlett</a>.
        </div>
        <div id="squareTwist">
            Comparison of square twist bistability, inspired by the paper
            <a href="http://cohengroup.lassp.cornell.edu/projects/bistable-origami-and-hidden-degrees-freedom" target="_blank">
                Origami structures with a critical transition to bistability arising from hidden degrees of freedom</a>.
            Switch to strain visualization to compare patterns.
        </div>
        <div id="miuraOri">
            Designed by <a href="https://en.wikipedia.org/wiki/Miura_fold" target="_blank">Koryo Miura</a>.
        </div>
        <div id="sam">
            Designed by <a href="http://www.mit.edu/~calisch/" target="_blank">Sam Calisch</a>.
        </div>
        <div id="kreuter">
            Designed by <a href="http://www.eascay.eu/" target="_blank">Johann Kreuter</a>.
        </div>
        <div id="mitani">
            Designed by <a href="https://mitani.cs.tsukuba.ac.jp/en/" target="_blank">Jun Mitani</a>.
        </div>
        <div id="mitaniCCbook">
            Designed by <a href="https://mitani.cs.tsukuba.ac.jp/en/" target="_blank">Jun Mitani</a>, crease pattern from the book <a href="https://mitani.cs.tsukuba.ac.jp/book/curved_folding/index.html" target="_blank">Curved-Folding Origami Design</a>.
        </div>
        <div id="mitani3Dbook">
            Designed by <a href="https://mitani.cs.tsukuba.ac.jp/en/" target="_blank">Jun Mitani</a>, crease pattern from the book <a href="https://mitani.cs.tsukuba.ac.jp/book/3d_origami_art/index.html" target="_blank">3D Origami Art</a>.
        </div>
        <div id="fellerKwan">
            Designed by <a href="https://www.instagram.com/polyscopes/" target="_blank">Kendrick Feller</a> based on the Spidron Tessellation by Daniel Kwan and similar spiral tessellations by Ekaterina Lukasheva.
        </div>
        <div id="fellerSmocked">
            Designed by <a href="https://www.instagram.com/polyscopes/" target="_blank">Kendrick Feller</a> based on a <a href="https://www.flickr.com/photos/dasssa/12455183674" target="_blank">smocked pattern</a> based on the origami of Alessandro Beber.
        </div>
        <div id="popupology">
            Designed by Elod Beregszaszi, original patterns available at <a href="http://www.popupology.co.uk/galleries" target="_blank">
            Popupology</a>.
        </div>
        <div id="ullagami">
            Designed by Ullagami, original pattern available at <a href="http://ullagami.com/how-to.php" target="_blank">
            Ullagami</a>.
        </div>
        <div id="whirlpool">
            Designed by Tomoko Fuse.  Crease pattern by <a href="http://www.happyfolding.com/" target="_blank">
            Sara Adams</a>.  Create your own variations using David O'Sullivan's <a href="https://observablehq.com/@dosull/tomoko-fuse-spiral-crease-patterns" target="_blank">parametric whirlpool design tool</a>.
        </div>
        <div id="miyamotoHappy">
            Designed by <a href="https://www.flickr.com/photos/yoshinobu_miyamoto/" target="_blank">Yoshinobu Miyamoto</a>.  Crease
            pattern from <a href="http://www.happyfolding.com/files/Miyamoto-RES_patterns.pdf" target="_blank">Happy Folding</a>.
        </div>
        <div id="polygami">
            This file was generated by <a href="https://alam-shahul.github.io/Polygami/" target="_blank">Polygami</a>,
            an app by Shahul Alam,
            Lauren Huang,
            and Mahi Shafiullah that creates crease patterns for any 2D arrangement of voxels on a square grid.
        </div>
        <div id="bistable">
            Allow this pattern to fold, then select <b>Allow User Interaction</b> (Advanced Options right menu) and drag the central vertex
            to pop into into an alternate, inverted configuration.
        </div>
        <div id="moosersTrain">
            Original design by Emmanuel Mooser. Crease pattern corrected and modified for rigid origami by William Gardner.
        </div>
        <div id="gardner">
            Based on Flower Tower design by Chris K. Palmer. Crease pattern files generated by William Gardner.
        </div>
        <div id="konjevod">
            Designed by <a href="https://www.organicorigami.com/" target="_blank">Goran Konjevod</a>.  Try folding these to ~65% and letting them settle to a curved shape.
        </div>
        <div id="milliron">
            Designed by Garrett Milliron based on the paper <a href="https://www.pnas.org/content/116/52/26407" target="_blank">"Programmable active kirigami metasheets with more freedom of actuation."</a>
            Generate more variations in <a href="https://observablehq.com/@gradies/auxetic-pleated-kirigami" target="_blank">this parametric design tool</a> for auxetic pleated kirigami.
        </div>
        <div id="lukasheva">
            Designed by <a href="https://www.instagram.com/ekaterina.lukasheva/" target="_blank">Ekaterina Lukasheva</a>.
        </div>
        <div id="lukashevaCCbook">
            Designed by <a href="https://www.instagram.com/ekaterina.lukasheva/" target="_blank">Ekaterina Lukasheva</a>, crease pattern from the book <a href="https://www.amazon.com/dp/0997311991" target="_blank">Curved Origami</a>.
        </div>
    </div>
</div>
<div class="modal fade" id="screenCaptureModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <b><span class="video">SCREEN RECORDING</span>
                    <span class="gif">ANIMATED GIF</span>
                    <span class="png">SAVE PNG</span>
                </b><br/><br/>
                <span class="gif video"><a href="#" id="setupAnimation" class="displayBlock btn btn-lg btn-default">Configure Fold Percent Animation</a>&nbsp;&nbsp;<span class="smallTxt" id="foldPercentAnimationStatus"></span><br/><br/></span>
                Filename: &nbsp;&nbsp;<input id="screenRecordFilename" value="" placeholder="" class="bigInput text form-control" type="text">
                    <span class="gif">.gif</span>
                    <span class="video">.webm</span>
                    <span class="png">.png</span>
                <br/><br/>
                Scale: &nbsp;&nbsp;<input id="capturerScale" value="" placeholder="" class="float form-control" type="text"> <br/>
                <span class="smallTxt">Increasing scale allows you to record at higher than screen resolution.</span><br/><br/>
                Dimensions: &nbsp;&nbsp;<b><span id="canvasDimensions"></span></b><br/>
                <span class="smallTxt">Resize browser window to change aspect ratio.</span><br/><br/>
                <span class="video">
                    Quality ( 0-63 ): &nbsp;&nbsp;<input id="capturerQuality" value="" placeholder="" class="float int form-control" type="text"><br/><br/>
                    Framerate ( 1-60 fps ): &nbsp;&nbsp;<input id="capturerFPS" value="" placeholder="" class="float int form-control" type="text"><br/><br/>
                </span>
                <span class="gif">
                    Framerate ( 1-60 fps ): &nbsp;&nbsp;<input id="gifFPS" value="" placeholder="" class="float int form-control" type="text"><br/><br/>
                </span>
                <span class="gif video">Num simulation steps per frame: &nbsp;&nbsp;<input value="" placeholder="" class="numStepsPerRender int form-control" type="text"><br/><br/></span>
                <span class="smallTxt">Notes: This feature captures the output of the canvas only - no UI or cursor
                    will be included.<span class="gif video">  Do not resize window while recording.  You can increase the
                amount of motion per frame by increasing the "Num simulation steps per frame".</span>  Check the <b>View</b> menu (above) for more rendering options.</span><br/>
            </div>
            <div class="modal-footer">
                <button id="doGifRecord" type="button" class="gif actionButton btn btn-success" data-dismiss="modal">Start</button>
                <button id="doScreenRecord" type="button" class="video actionButton btn btn-success" data-dismiss="modal">Start</button>
                <button id="doPNGCapture" type="button" class="png actionButton btn btn-success" data-dismiss="modal">Save</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="animationSetupModal" tabindex="-1" role="dialog" aria-labelledby="basicModal" aria-hidden="true">
    <div class="modal-dialog modal-med">
        <div class="modal-content">
            <div class="modal-body">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
                <b>FOLD PERCENT ANIMATION SETUP</b><br/>
                <p>
                    Current Fold Percent: &nbsp;&nbsp;<input value="" placeholder="" id="currentFoldPercent" class="float form-control" type="text">&nbsp;&nbsp;%<br/><br/>
                    <span id="animationSetupHelp"></span>
                    <ul id="animationHTML"></ul>
                    <div class="btns"><a href="#" id="addDelay" class="displayBlock btn btn-lg btn-warning">Add Delay</a>&nbsp;&nbsp;&nbsp;
                    <a href="#" id="addAnimationItem" class="displayBlock btn btn-lg btn-success">Add Animation</a></div>
                </p>
            </div>
            <div class="modal-footer">
                <button id="finishAnimationSetup" type="button" class="actionButton btn btn-success" data-dismiss="modal">Done</button>
            </div>
        </div>
    </div>
</div>
<div id="recordStatus">
    <a href="#" id="stopRecord" class="btn btn-lg btn-danger">Stop Record <span></span></a>
</div>
<a href="#" id="aboutCorner">?</a>

<script>
    // Random Seed Control Functions
    function applyRandomSeed() {
        // Early check for globals availability
        if (typeof globals === 'undefined' || !globals || !globals.setRandomSeed) {
            console.warn('🚨 Globals not yet available for random seed application');
            return false;
        }
        
        var seedInput = document.getElementById('randomSeed');
        if (!seedInput) {
            console.warn('🚨 Random seed input element not found');
            return false;
        }
        
        var seed = seedInput.value.trim();
        
        if (!seed) {
            alert('Please enter a seed value');
            return;
        }
        
        console.log('🔄 UI: Applying new random seed:', seed);
        console.log('🔄 UI: Current time:', new Date().toISOString());
        
        // Apply the seed through globals
        if (typeof globals !== 'undefined' && globals.setRandomSeed) {
            console.log('🔄 UI: Calling globals.setRandomSeed...');
            
            // Clear any existing assignments first to ensure clean slate
            if (globals.faceTextureMapping) {
                console.log('🔄 UI: Clearing existing face texture mapping');
                globals.faceTextureMapping = {};
            }
            
            // Apply the new seed - this will trigger reassignment
            globals.setRandomSeed(seed);
            
            console.log('✅ UI: Random seed applied successfully');
            console.log('📊 UI: Texture library size:', globals.textureLibrary ? globals.textureLibrary.length : 0);
            console.log('📊 UI: Face mapping size:', Object.keys(globals.faceTextureMapping || {}).length);
            
            // Show confirmation
            var statusElement = document.createElement('span');
            statusElement.textContent = '✅ Seed applied: ' + seed + ' (Deterministic mode active)';
            statusElement.style.color = '#27ae60';
            statusElement.style.marginLeft = '10px';
            statusElement.style.fontSize = '12px';
            statusElement.style.fontWeight = 'bold';
            
            var container = seedInput.parentNode;
            var existingStatus = container.querySelector('.seed-status');
            if (existingStatus) {
                existingStatus.remove();
            }
            
            statusElement.className = 'seed-status';
            container.appendChild(statusElement);
            
            setTimeout(function() {
                if (statusElement.parentNode) {
                    statusElement.remove();
                }
            }, 5000); // Show for 5 seconds
            
        } else {
            console.warn('🚨 Globals not available or setRandomSeed function not found');
            console.log('🚨 typeof globals:', typeof globals);
            console.log('🚨 globals object:', globals);
            alert('Random seed system not available. Please wait for the application to fully load.');
        }
    }
    
    function resetRandomSeed() {
        var seedInput = document.getElementById('randomSeed');
        if (seedInput) {
            seedInput.value = 'origami-simulator-2024';
            applyRandomSeed();
        }
    }
    
    // Initialize random seed when page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Handle editMode functionality
        if (typeof editMode !== 'undefined' && editMode === false) {
            console.log('🚫 Edit mode disabled - hiding navigation and suppressing alerts');
            
            // Add CSS class to body for styling
            document.body.classList.add('edit-mode-disabled');
            
            // Hide navigation bar
            var navBar = document.getElementById('globalNav');
            if (navBar) {
                navBar.style.display = 'none';
                console.log('✅ Navigation bar hidden');
            }
            
            // Initially hide all controls
            var controlsBottom = document.getElementById('controlsBottom');
            if (controlsBottom) {
                controlsBottom.style.display = 'none';
                console.log('✅ Bottom controls initially hidden');
            }
            
            // Function to show controls after rendering is complete
            window.showControlsAfterRender = function() {
                console.log('🎬 Starting control visibility sequence...');
                window.nftRenderComplete = true;
                console.log('✅ Set window.nftRenderComplete = true');
                
                setTimeout(function() {
                    var controlsBottom = document.getElementById('controlsBottom');
                    if (controlsBottom) {
                        controlsBottom.style.display = 'flex';
                        console.log('✅ Bottom controls shown after 5 second delay');
                    }
                }, 5000); // 5秒に戻す（スクリーンショット撮影の余裕を作る）
            };
            
            // Suppress alerts by overriding alert function
            window.alert = function(message) {
                console.log('🔇 Alert suppressed in non-edit mode:', message);
            };
            
            // Suppress other alert-related functions
            window.confirm = function(message) {
                console.log('🔇 Confirm dialog suppressed in non-edit mode:', message);
                return true; // Default to true for non-disruptive behavior
            };
            
            window.prompt = function(message, defaultText) {
                console.log('🔇 Prompt dialog suppressed in non-edit mode:', message);
                return defaultText || '';
            };
            
            // Optionally suppress console errors and warnings for cleaner presentation
            var originalConsoleError = console.error;
            var originalConsoleWarn = console.warn;
            
            console.error = function() {
                // Still log errors but mark them as suppressed
                var args = Array.prototype.slice.call(arguments);
                args.unshift('🔇 [SUPPRESSED ERROR]:');
                originalConsoleError.apply(console, args);
            };
            
            console.warn = function() {
                // Still log warnings but mark them as suppressed  
                var args = Array.prototype.slice.call(arguments);
                args.unshift('🔇 [SUPPRESSED WARNING]:');
                originalConsoleWarn.apply(console, args);
            };
            
            console.log('✅ Edit mode restrictions applied');
            
            // Set globals.editMode when globals is available
            if (typeof globals !== 'undefined') {
                globals.editMode = false;
                console.log('🔧 Set globals.editMode = false');
            } else {
                // Wait for globals to be available and then set editMode
                var checkGlobals = setInterval(function() {
                    if (typeof globals !== 'undefined') {
                        globals.editMode = false;
                        console.log('🔧 Set globals.editMode = false (delayed)');
                        clearInterval(checkGlobals);
                    }
                }, 100);
            }
        } else {
            console.log('✏️  Edit mode enabled - full interface available');
            
            // Set globals.editMode when globals is available
            if (typeof globals !== 'undefined') {
                globals.editMode = true;
                console.log('🔧 Set globals.editMode = true');
            } else {
                // Wait for globals to be available and then set editMode
                var checkGlobals = setInterval(function() {
                    if (typeof globals !== 'undefined') {
                        globals.editMode = true;
                        console.log('🔧 Set globals.editMode = true (delayed)');
                        clearInterval(checkGlobals);
                    }
                }, 100);
            }
        }
        
        console.log('🎲 Setting up random seed controls');
        
        // Sync window.nftData with local nftData if injected from server
        if (typeof window.nftData !== 'undefined' && window.nftData) {
            console.log('🔄 Syncing injected nftData from server');
            window.nftData = window.nftData;
        } else if (typeof nftData !== 'undefined') {
            console.log('🔄 Using default nftData');
            window.nftData = nftData;
        } else {
            console.log('⚠️  No nftData available');
            window.nftData = null;
        }
        
        // Set up enter key handler for seed input
        var seedInput = document.getElementById('randomSeed');
        if (seedInput) {
            seedInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    applyRandomSeed();
                }
            });
        }

        // Set up download button handler for texture images
        var dlButton = document.getElementById('dlButton');
        if (dlButton) {
            dlButton.addEventListener('click', function(e) {
                e.preventDefault();
                
                console.log('Download button clicked');
                
                // Check if cellColorizer is available and has generateTextureMappedCellImage function
                if (typeof globals !== 'undefined' && globals.cellColorizer && 
                    typeof globals.cellColorizer.generateTextureMappedCellImage === 'function') {
                    
                    console.log('Generating and downloading texture-mapped cell image...');
                    globals.cellColorizer.generateTextureMappedCellImage(false); // false = manual mode, will download
                    
                } else if (typeof globals !== 'undefined' && globals.textureLibrary && 
                          globals.textureLibrary.length > 0) {
                    
                    // Fallback: download the first texture from library
                    console.log('Downloading first texture from library...');
                    downloadTextureFromLibrary(0);
                    
                } else {
                    // No textures available
                    console.warn('No textures available to download');
                    alert('No texture images are currently loaded to download.');
                }
            });
        }

        // Set up print button handler for crease pattern SVG
        var printButton = document.getElementById('printButton');
        if (printButton) {
            printButton.addEventListener('click', function(e) {
                e.preventDefault();
                
                console.log('Print button clicked');
                
                // Check if pattern is available for SVG export
                if (typeof globals !== 'undefined' && globals.pattern && 
                    typeof globals.pattern.saveSVG === 'function') {
                    
                    console.log('Exporting crease pattern as SVG for printing...');
                    globals.pattern.saveSVG();
                    
                } else if (typeof globals !== 'undefined' && globals.curvedFolding && 
                          typeof globals.curvedFolding.saveSVG === 'function') {
                    
                    console.log('Exporting curved folding pattern as SVG for printing...');
                    globals.curvedFolding.saveSVG();
                    
                } else if (typeof globals !== 'undefined' && globals.threeView && 
                          typeof globals.threeView.saveSVG === 'function') {
                    
                    console.log('Exporting 3D view as SVG for printing...');
                    globals.threeView.saveSVG();
                    
                } else {
                    // Try alternative approach - take a screenshot and open print dialog
                    console.log('SVG export not available, using alternative print method...');
                    printCurrentView();
                }
            });
        }

        // Function to print current view using browser's print functionality
        function printCurrentView() {
            try {
                // Hide UI elements temporarily for cleaner print
                var elementsToHide = [
                    document.getElementById('globalNav'),
                    document.getElementById('controlsLeft'),
                    document.getElementById('controlsBottom'),
                    document.querySelector('.main-content')
                ];
                
                var originalStyles = [];
                elementsToHide.forEach(function(element, index) {
                    if (element) {
                        originalStyles[index] = element.style.display;
                        element.style.display = 'none';
                    }
                });
                
                // Create print-specific styles
                var printStyles = document.createElement('style');
                printStyles.type = 'text/css';
                printStyles.innerHTML = `
                    @media print {
                        body { margin: 0; padding: 0; }
                        #threeView { 
                            width: 100% !important; 
                            height: 100% !important; 
                            position: fixed !important;
                            top: 0 !important;
                            left: 0 !important;
                        }
                        .no-print { display: none !important; }
                    }
                `;
                document.head.appendChild(printStyles);
                
                // Trigger print dialog
                setTimeout(function() {
                    window.print();
                    
                    // Restore original styles after print dialog
                    setTimeout(function() {
                        elementsToHide.forEach(function(element, index) {
                            if (element) {
                                element.style.display = originalStyles[index];
                            }
                        });
                        document.head.removeChild(printStyles);
                    }, 1000);
                }, 100);
                
            } catch (error) {
                console.error('Error in print functionality:', error);
                alert('Print functionality is not available at the moment.');
            }
        }

        // Function to download texture from library
        function downloadTextureFromLibrary(index) {
            if (typeof globals === 'undefined' || !globals.textureLibrary || 
                index >= globals.textureLibrary.length) {
                console.error('Texture index out of range or no textures available');
                return;
            }
            
            var texture = globals.textureLibrary[index];
            if (!texture || !texture.image) {
                console.error('Invalid texture at index', index);
                return;
            }
            
            // Create canvas to convert texture to downloadable format
            var canvas = document.createElement('canvas');
            canvas.width = texture.image.width;
            canvas.height = texture.image.height;
            var ctx = canvas.getContext('2d');
            
            // Draw the texture image to canvas
            ctx.drawImage(texture.image, 0, 0);
            
            // Convert to blob and download
            canvas.toBlob(function(blob) {
                if (blob) {
                    var url = URL.createObjectURL(blob);
                    var downloadLink = document.createElement("a");
                    downloadLink.href = url;
                    
                    var filename = texture.name || ('texture_' + index + '.png');
                    // Ensure filename has .png extension
                    if (!filename.toLowerCase().endsWith('.png') && 
                        !filename.toLowerCase().endsWith('.jpg') && 
                        !filename.toLowerCase().endsWith('.jpeg')) {
                        filename += '.png';
                    }
                    
                    downloadLink.download = filename;
                    
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    URL.revokeObjectURL(url);
                    
                    console.log("Texture downloaded successfully:", filename);
                } else {
                    console.error("Failed to create blob for texture download");
                }
            }, 'image/png');
        }

        // Process nftData after a delay to ensure all scripts are loaded
        setTimeout(function() {
        // Process nftData if available
        var dataToProcess = window.nftData;
        if (dataToProcess) {
            console.log('NFT Data detected:', dataToProcess);
            
            // Set NFT processing flag
            if (typeof globals !== 'undefined') {
                globals.isNFTProcessing = true;
                console.log('🤖 Set globals.isNFTProcessing = true');
                
                // Hide origami object until textures are fully applied
                if (globals.model && globals.model.hideOrigami) {
                    globals.model.hideOrigami();
                } else {
                    // Wait for model to be available
                    var hideWaitInterval = setInterval(function() {
                        if (globals.model && globals.model.hideOrigami) {
                            globals.model.hideOrigami();
                            clearInterval(hideWaitInterval);
                        }
                    }, 100);
                }
            }
            
            // Add debug logging for origami patterns
            console.log('ORIGAMI PATTERN DEBUG:');
            console.log('- typeof origamiPatterns:', typeof origamiPatterns);
            console.log('- origamiPatterns:', window.origamiPatterns || origamiPatterns);
            console.log('- window.origamiPatterns exists:', 'origamiPatterns' in window);
            
            // First, randomly select and load an origami pattern
            if (typeof origamiPatterns !== 'undefined' && origamiPatterns.length > 0) {
                console.log('� Checking origamiPatterns variable:', typeof origamiPatterns, origamiPatterns);
                console.log('�📋 Available origami patterns:', origamiPatterns.length);
                
                // Use wallet address as seed for pattern selection to ensure consistency
                var patternSeed = dataToProcess.walletAddress + dataToProcess.seed2 || 'default-seed';
                console.log('🌱 Using pattern seed:', patternSeed);
                
                var patternHash = 0;
                for (var i = 0; i < patternSeed.length; i++) {
                    patternHash = ((patternHash << 5) - patternHash + patternSeed.charCodeAt(i)) & 0xffffffff;
                }
                var patternIndex = Math.abs(patternHash) % origamiPatterns.length;
                var selectedPattern = origamiPatterns[patternIndex];
                
                console.log('🎲 Pattern selection calculation:');
                console.log('  - Hash value:', patternHash);
                console.log('  - Calculated index:', patternIndex);
                console.log('  - Selected pattern:', selectedPattern);
                
                console.log('� Selected origami pattern (index ' + patternIndex + '):', selectedPattern.url);
                
                // Load the selected origami pattern first
                console.log('📥 Starting to fetch pattern from:', selectedPattern.url);
                fetch(selectedPattern.url)
                    .then(function(response) {
                        if (!response.ok) {
                            throw new Error('Failed to load pattern: ' + response.status);
                        }
                        return response.text();
                    })
                    .then(function(svgContent) {
                        console.log('✅ Origami pattern loaded successfully, content length:', svgContent.length);
                        
                        // Parse and load the SVG pattern
                        console.log('🔍 Checking globals.importer availability:', typeof globals, globals && typeof globals.importer);
                        console.log('🔍 Importer methods available:', globals && globals.importer ? Object.keys(globals.importer) : 'none');
                        
                        if (typeof globals !== 'undefined' && globals.importer && typeof globals.importer.importSVG === 'function') {
                            console.log('📐 Importing SVG pattern using globals.importer.importSVG...');
                            
                            // Register callback to proceed with NFT processing after pattern loads
                            if (globals.onPatternLoaded) {
                                globals.onPatternLoaded(function(patternInfo) {
                                    console.log('🔔 Pattern loaded callback triggered:', patternInfo);
                                    console.log('🔄 Proceeding to NFT processing after successful pattern import...');
                                    processNFTData(dataToProcess);
                                });
                            }
                            
                            try {
                                var importResult = globals.importer.importSVG(svgContent, selectedPattern.url);
                                if (importResult) {
                                    console.log('✅ SVG pattern import initiated successfully');
                                    
                                    // Set the maxFolding value for this pattern
                                    if (selectedPattern.maxFolding && globals.setMaxFolding) {
                                        console.log('📏 Setting maxFolding to:', selectedPattern.maxFolding);
                                        globals.setMaxFolding(selectedPattern.maxFolding);
                                    }
                                    
                                } else {
                                    console.warn('⚠️ SVG import returned false - pattern may not have loaded correctly');
                                    // Fallback to proceeding with NFT processing
                                    setTimeout(function() {
                                        console.log('🔄 Proceeding to NFT processing after import failure...');
                                        processNFTData(dataToProcess);
                                    }, 1000);
                                }
                            } catch (importError) {
                                console.error('❌ Error importing SVG:', importError);
                                console.error('Stack trace:', importError.stack);
                                // Fallback to proceeding with NFT processing
                                setTimeout(function() {
                                    console.log('🔄 Proceeding to NFT processing after import error...');
                                    processNFTData(dataToProcess);
                                }, 1000);
                            }
                        } else {
                            var reason = '';
                            if (typeof globals === 'undefined') reason = 'globals undefined';
                            else if (!globals.importer) reason = 'importer not found';
                            else if (typeof globals.importer.importSVG !== 'function') reason = 'importSVG not a function';
                            
                            console.warn('⚠️ SVG importer not available (' + reason + '), proceeding with NFT processing anyway');
                            processNFTData(dataToProcess);
                        }
                    })
                    .catch(function(error) {
                        console.error('❌ Failed to load origami pattern:', error);
                        console.log('🔄 Proceeding with NFT processing anyway...');
                        processNFTData(dataToProcess);
                    });
            } else {
                console.warn('⚠️ origamiPatterns not available!');
                console.log('  - Type:', typeof origamiPatterns);
                console.log('  - Value:', origamiPatterns);
                console.log('🔄 Proceeding with NFT processing without pattern loading');
                processNFTData(dataToProcess);
            }
        } else {
            console.log('ℹ️  No NFT data available, using default configuration');
        }
        
        // Function to process NFT data (wallet address and textures)
        function processNFTData(dataToProcess) {
            console.log('🎯 Processing NFT data:', dataToProcess);
            
            // Set wallet address as random seed
            if (dataToProcess.walletAddress) {
                console.log('🔑 Setting wallet address as random seed:', dataToProcess.walletAddress);
                var seedInput = document.getElementById('randomSeed');
                if (seedInput) {
                    seedInput.value = dataToProcess.walletAddress;
                    
                    // Wait for globals to be available before applying seed
                    var waitForGlobalsAndApplySeed = function() {
                        if (typeof globals !== 'undefined' && globals.setRandomSeed) {
                            console.log('✅ Globals available, applying wallet address as random seed');
                            applyRandomSeed();
                            console.log('✅ Wallet address applied as random seed');
                        } else {
                            console.log('⏳ Waiting for globals to apply random seed...');
                            setTimeout(waitForGlobalsAndApplySeed, 100);
                        }
                    };
                    
                    waitForGlobalsAndApplySeed();
                }
            }
            
            // Process images for texture loading
            if (dataToProcess.images && Array.isArray(dataToProcess.images) && dataToProcess.images.length > 0) {
                console.log('🖼️  Loading NFT images as textures:', dataToProcess.images.length, 'images');
                
                // Wait for globals to be available
                var checkGlobals = function() {
                    if (typeof globals !== 'undefined' && globals.textureLibrary && typeof THREE !== 'undefined') {
                        console.log('✅ Globals and THREE.js available, loading textures...');
                        
                        // Clear existing textures
                        globals.textureLibrary = [];
                        
                        // Create texture loader
                        var loader = new THREE.TextureLoader();
                        loader.crossOrigin = 'anonymous';
                        
                        var loadedCount = 0;
                        var totalImages = dataToProcess.images.length;
                        
                        // Textures will be applied immediately after loading - no need for complex model checking
                        
                        // Load each image as texture
                        dataToProcess.images.forEach(function(imageData, index) {
                            if (imageData.url) {
                                console.log('🔄 Loading texture', (index + 1) + '/' + dataToProcess.images.length + ':', imageData.url);
                                
                                loader.load(
                                    imageData.url,
                                    function(texture) {
                                        // Success callback
                                        console.log('✅ Texture loaded successfully:', imageData.url);
                                        
                                        // Configure texture
                                        texture.wrapS = THREE.RepeatWrapping;
                                        texture.wrapT = THREE.RepeatWrapping;
                                        texture.repeat.set(globals.textureRepeat || 1.0, globals.textureRepeat || 1.0);
                                        texture.flipY = false;
                                        texture.generateMipmaps = true;
                                        texture.minFilter = THREE.LinearFilter;
                                        texture.magFilter = THREE.LinearFilter;
                                        texture.name = 'NFT_Image_' + (index + 1);
                                        
                                        // Add to texture library
                                        globals.textureLibrary.push(texture);
                                        loadedCount++;
                                        
                                        // Update texture list UI
                                        var textureList = document.getElementById('textureList');
                                        if (textureList) {
                                            var item = document.createElement('div');
                                            item.className = 'texture-item';
                                            item.style.cssText = 'padding: 5px; margin: 2px 0; background: #f0f0f0; border-radius: 3px; font-size: 12px;';
                                            item.textContent = '✅ ' + imageData.url.split('/').pop();
                                            textureList.appendChild(item);
                                        }
                                        
                                        // Check if all textures loaded
                                        if (loadedCount === totalImages) {
                                            console.log('🎉 All NFT textures loaded successfully!', loadedCount, 'textures');
                                            
                                            // Enable random texture assignment
                                            var randomTexturesCheckbox = document.getElementById('randomTextures');
                                            if (randomTexturesCheckbox) {
                                                randomTexturesCheckbox.checked = true;
                                                console.log('✅ Random texture assignment enabled');
                                            }
                                            
                                            // Apply textures immediately - model should be ready by now
                                            setTimeout(function() {
                                                if (globals.assignRandomTextures) {
                                                    console.log('🔄 Triggering random texture assignment...');
                                                    globals.assignRandomTextures();
                                                    
                                                    // Generate texture-mapped cells (equivalent to File → Generate Texture-Mapped Cells...)
                                                    setTimeout(function() {
                                                        if (globals.cellColorizer && globals.cellColorizer.generateTextureMappedCellImage) {
                                                            console.log('🎨 Generating texture-mapped cells automatically...');
                                                            globals.cellColorizer.generateTextureMappedCellImage(true); // true for auto mode
                                                            console.log('✅ Texture-mapped cells generated - textures should now be visible');
                                                            
                                                            // Force render updates after generating texture-mapped cells
                                                            setTimeout(function() {
                                                                try {
                                                                    if (typeof getSolver === 'function' && getSolver() && getSolver().render) {
                                                                        getSolver().render();
                                                                        console.log('🖼️ Final render update triggered');
                                                                    }
                                                                } catch (renderError) {
                                                                    console.log('ℹ️ Render update not available:', renderError.message);
                                                                }
                                                                
                                                                // Reset NFT processing flag
                                                                if (typeof globals !== 'undefined') {
                                                                    globals.isNFTProcessing = false;
                                                                    console.log('🏁 NFT processing completed - reset isNFTProcessing flag');
                                                                    
                                                                    // Show origami object now that textures are applied
                                                                    if (globals.model && globals.model.showOrigami) {
                                                                        globals.model.showOrigami();
                                                                    }
                                                                    
                                                                    // Set global rendering completion flag for screenshot detection
                                                                    window.renderingComplete = true;
                                                                    console.log('🎯 Set window.renderingComplete = true for thumbnail detection');
                                                                    
                                                                    // Trigger control visibility sequence
                                                                    if (typeof window.showControlsAfterRender === 'function') {
                                                                        window.showControlsAfterRender();
                                                                        console.log('🎬 Triggered control visibility sequence');
                                                                    }
                                                                }
                                                            }, 500);
                                                        } else {
                                                            console.warn('⚠️ cellColorizer.generateTextureMappedCellImage not available');
                                                        }
                                                    }, 500);
                                                    
                                                    // Force a render update if possible
                                                    try {
                                                        if (typeof getSolver === 'function' && getSolver() && getSolver().render) {
                                                            getSolver().render();
                                                            console.log('�️ Render update triggered');
                                                        }
                                                    } catch (renderError) {
                                                        console.log('ℹ️ Render update not available:', renderError.message);
                                                    }
                                                } else {
                                                    console.warn('⚠️ assignRandomTextures function not available');
                                                }
                                            }, 1000);
                                        }
                                    },
                                    function(progress) {
                                        // Progress callback
                                        console.log('📊 Loading progress for', imageData.url, ':', progress);
                                    },
                                    function(error) {
                                        // Error callback
                                        console.error('❌ Failed to load texture:', imageData.url, error);
                                        loadedCount++;
                                        
                                        // Update texture list UI with error
                                        var textureList = document.getElementById('textureList');
                                        if (textureList) {
                                            var item = document.createElement('div');
                                            item.className = 'texture-item error';
                                            item.style.cssText = 'padding: 5px; margin: 2px 0; background: #ffe6e6; border-radius: 3px; font-size: 12px; color: #cc0000;';
                                            item.textContent = '❌ Failed: ' + imageData.url.split('/').pop();
                                            textureList.appendChild(item);
                                        }
                                        
                                        // Check if all textures processed (loaded or failed)
                                        if (loadedCount === totalImages) {
                                            console.log('🏁 All NFT textures processed. Successful:', globals.textureLibrary.length, '/', totalImages);
                                        }
                                    }
                                );
                            }
                        });
                        
                    } else {
                        console.log('⏳ Waiting for globals and THREE.js to be available...');
                        setTimeout(checkGlobals, 100);
                    }
                };
                
                // Start checking for globals
                checkGlobals();
            }
        } // End processNFTData function
        
        }, 1000); // Wait 1 second for all scripts to load

        setTimeout(() => {
            window.nftRenderComplete = true;
        }, 2000);

    });
</script>

</body>
</html>
